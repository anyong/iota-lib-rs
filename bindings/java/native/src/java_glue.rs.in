use std::{
    time::Duration,
    str::FromStr,
};

use crate::{
    client_builder::*,
    full_node_api::*,
    balance::*,
    jni_c_header::*,
    bee_types::*,
    message::*,
    address::*,
    ed25519::*,
};
use iota_client::{
    Api, bee_message::MessageId,
    bee_rest_api::types::dtos::LedgerInclusionStateDto,
};
use anyhow::{
    anyhow,
    Result as Result,
};


foreign_class!(class RustLogging {
    fn init() {
        env_logger::init();
    }
});

foreign_enum!(
    enum Api {
        /// `get_health` API
        GET_HEALTH = Api::GetHealth,
        /// `get_info`API
        GET_INFO = Api::GetInfo,
        /// `get_peers`API
        GET_PEERS = Api::GetPeers,
        /// `get_tips` API
        GET_TIPS = Api::GetTips,
        /// `post_message` API
        POST_MESSAGE = Api::PostMessage,
        /// `post_message` API with remote pow
        POST_MESSAGE_WITH_REMOTE_POW= Api::PostMessageWithRemotePow,
        /// `get_output` API
        GET_OUTPUT = Api::GetOutput,
        /// `get_milestone` API
        GET_MILESTONE = Api::GetMilestone,
        /// `get_message` API
        GET_MESSAGE  = Api::GetMessage,
        /// `get_balance` API
        GET_BALANCE = Api::GetBalance,
    }
);

foreign_enum!(
    enum Relation {
        KNOWN = Relation::KNOWN,
        UNKNOWN = Relation::UNKNOWN,
        DISCOVERED = Relation::DISCOVERED,
    }
);

foreign_enum!(
    enum OutputKind {
        SIGNATURE_LOCKED_SINGLE = OutputKind::SignatureLockedSingle,
        SIGNATURE_LOCKED_DUST_ALLOWANCE = OutputKind::SignatureLockedDustAllowance,
        TREASURY = OutputKind::Treasury,
    }
);

foreign_enum!(
    enum LedgerInclusionStateDto {
        CONFLICTING = LedgerInclusionStateDto::Conflicting,
        INCLUDED = LedgerInclusionStateDto::Included,
        NO_TRANSACTION = LedgerInclusionStateDto::NoTransaction,
    }
);

foreign_class!(
    class BrokerOptions {
        #[derive(camelCaseAliases)]
        self_type BrokerOptions;
        constructor BrokerOptions::new() -> BrokerOptions;
        fn BrokerOptions::automatic_disconnect(&self, disconnect: bool) -> BrokerOptions;
        fn BrokerOptions::timeout(&self, timeout: Duration) -> BrokerOptions;
        fn BrokerOptions::max_reconnection_attempts(&self, max_reconnection_attempts: usize) -> BrokerOptions;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class ClientBuilder {
        self_type ClientBuilder;
        constructor ClientBuilder::new() -> ClientBuilder;
        fn ClientBuilder::with_node(&mut self, node: &str) -> ClientBuilder;
        fn ClientBuilder::with_node_pool_urls(&mut self, node_pool_urls: Vec<String>) -> ClientBuilder;
        fn ClientBuilder::with_network(&mut self, network: String) -> ClientBuilder;
        fn ClientBuilder::with_node_sync_interval(&mut self, node_sync_interval: Duration) -> ClientBuilder;
        fn ClientBuilder::with_node_sync_disabled(&mut self) -> ClientBuilder;
        fn ClientBuilder::with_mqtt_broker_options(&mut self, options: BrokerOptions) -> ClientBuilder;
        fn ClientBuilder::with_local_pow(&mut self, local: bool) -> ClientBuilder;
        fn ClientBuilder::with_request_timeout(&mut self, timeout: Duration) -> ClientBuilder;
        fn ClientBuilder::with_api_timeout(&mut self, api: Api, timeout: Duration) -> ClientBuilder;
        fn ClientBuilder::finish(&mut self) -> Result<Client>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class Client {
        self_type Client;
        private constructor = empty;
        fn Client::builder() -> ClientBuilder; alias Builder;
        
        /// GET /health endpoint
        fn Client::get_health(&self) -> Result<bool>;
        fn Client::get_node_health(&self, node: &str) -> Result<bool>;
        

        /// GET /api/v1/info endpoint
        fn Client::get_info(&self) -> Result<NodeInfoWrapper>; 
        
        /// GET /api/v1/peers endpoint
        fn Client::get_peers(&self) -> Result<Vec<PeerDto>>;

        /// GET /api/v1/tips endpoint
        fn Client::get_tips(&self) -> Result<Vec<String>>;

        /// GET /api/v1/outputs/{outputId} endpoint
        /// Find an output by its transaction_id and corresponding output_index.
        fn Client::get_output(&self, output_id: String) -> Result<OutputResponse>;

        /// GET /api/v1/addresses/{address} endpoint
        fn Client::get_address(&self) -> GetAddressBuilderNode;

        /// Return the balance in iota for the given address; No seed or security level needed to do this
        /// since we are only checking and already know the address.
        fn Client::get_address_balance(&self, address: &str) -> Result<BalanceAddressResponse>;

        // Return the balance in iota for the given addresses; No seed or security level needed to do this
        /// since we are only checking and already know the addresses.
        fn Client::get_addresses_balances(&self, addresses: Vec<String>) -> Result<Vec<BalanceAddressResponse>>;

        /// Find all outputs based on the requests criteria. This method will try to query multiple nodes if
        /// the request amount exceeds individual node limit.
        fn Client::find_outputs(&self, output_ids: Option<Vec<String>>, addresses: Option<Vec<String>>) -> Result<Vec<OutputResponse>>;
        
        /// GET /api/v1/milestones/{index} endpoint
        /// Get the milestone by the given index.
        fn Client::get_milestone(&self, index: u32) -> Result<MilestoneResponse>;
        
        /// GET /api/v1/milestones/{index}/utxo-changes endpoint
        /// Get the milestone by the given index.
        fn Client::get_milestone_utxo_changes(&self, index: u32) -> Result<MilestoneUtxoChangesResponse>;

        /// GET /api/v1/receipts endpoint
        /// Get all receipts.
        fn Client::get_receipts(&self) -> Result<Vec<ReceiptDto>>;

        /// GET /api/v1/receipts/{migratedAt} endpoint
        /// Get the receipts by the given milestone index.
        fn Client::get_receipts_migrated_at(&self, index: u32) -> Result<Vec<ReceiptDto>>;

        /// Reattaches messages for provided message id. Messages can be reattached only if they are valid and haven't been
        /// confirmed for a while.
        fn Client::reattach(&self, message_id: MessageId) -> Result<MessageWrap>;
        
        /// Reattach a message without checking if it should be reattached
        fn Client::reattach_unchecked(&self, message_id: MessageId) -> Result<MessageWrap>;
        
        /// Promotes a message. The method should validate if a promotion is necessary through get_message. If not, the
        /// method should error out and should not allow unnecessary promotions.
        fn Client::promote(&self, message_id: MessageId) -> Result<MessageWrap>;
        
        /// Promote a message without checking if it should be promoted
        fn Client::promote_unchecked(&self, message_id: MessageId) -> Result<MessageWrap>;

        /// Return the balance for a provided seed and its wallet chain account index.
        /// Addresses with balance must be consecutive, so this method will return once it encounters a zero
        /// balance address.
        fn Client::get_balance(&self, seed: &str) -> GetBalanceBuilderApi;

        fn Client::message(&self) -> ClientMessageBuilder;

        /// Transforms bech32 to hex
        fn Client::bech32_to_hex(bech32: &str) -> Result<String>;
        /// Transforms hex to bech32
        fn Client::hex_to_bech32(&self, hex: &str, bech32_hrp: Option<&str>) -> Result<String>;
        /// Checks if a String address is valid.
        fn Client::is_address_valid(address: &str) -> bool;

        /// Returns a valid Address parsed from a String.
        fn Client::parse_bech32_address(address: &str) -> Result<Address>;
    }
);

foreign_class!(
    #[derive(PartialEq, Display)]
    class NodeInfoWrapper {
        self_type NodeInfoWrapper;
        private constructor = empty;
        private fn NodeInfoWrapper::to_string(&self) -> String; alias to_string;
        private fn NodeInfoWrapper::eq(&self, o: &NodeInfoWrapper) -> bool; alias rustEq;
        fn NodeInfoWrapper::url(&self) -> &str; alias getUrl;
        fn NodeInfoWrapper::nodeinfo(&self) -> InfoResponse; alias nodeInfo;
    }
);

foreign_class!(
    #[derive(PartialEq, Display)]
    class InfoResponse {
        self_type InfoResponse;
        private constructor = empty;
        private fn InfoResponse::to_string(&self) -> String; alias to_string;
        private fn InfoResponse::eq(&self, o: &InfoResponse) -> bool; alias rustEq;
        fn InfoResponse::name(&self) -> &str;
        fn InfoResponse::version(&self) -> &str;
        fn InfoResponse::network_id(&self) -> &str; alias networkId;
        fn InfoResponse::bech32_hrp(&self) -> &str; alias bech32HRP;
        fn InfoResponse::messages_per_second(&self) -> f64; alias messagesPerSecond;
        fn InfoResponse::referenced_messages_per_second(&self) -> f64; alias referencedMessagesPerSecond;
        fn InfoResponse::referenced_rate(&self) -> f64; alias referencedRate;
        fn InfoResponse::latest_milestone_timestamp(&self) -> u64; alias latestMilestoneTimestamp;
        fn InfoResponse::min_pow_score(&self) -> f64; alias minPoWScore;
        fn InfoResponse::latest_milestone_index(&self) -> u32; alias latestMilestoneIndex;
        fn InfoResponse::confirmed_milestone_index(&self) -> u32; alias confirmedMilestoneIndex;
        fn InfoResponse::pruning_index(&self) -> u32; alias pruningIndex;
        fn InfoResponse::features(&self) -> Vec<String>;
    }
);

foreign_class!(
    #[derive(PartialEq, camelCaseAliases, Display)]
    class BalanceAddressResponse {
        self_type BalanceAddressResponse;
        private constructor = empty;
        private fn BalanceAddressResponse::to_string(&self) -> String; alias to_string;
        private fn BalanceAddressResponse::eq(&self, o: &BalanceAddressResponse) -> bool; alias rustEq;
        fn BalanceAddressResponse::address_type(&self) -> u8;
        fn BalanceAddressResponse::address(&self) -> &str;
        fn BalanceAddressResponse::balance(&self) -> u64;
        fn BalanceAddressResponse::dust_allowed(&self) -> bool;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class OutputResponse {
        self_type OutputResponse;
        private constructor = empty;
        private fn OutputResponse::to_string(&self) -> String; alias to_string;
        fn OutputResponse::message_id(&self) -> &str;
        fn OutputResponse::transaction_id(&self) -> &str;
        fn OutputResponse::output_index(&self) -> u16;
        fn OutputResponse::is_spent(&self) -> bool;
        fn OutputResponse::output(&self) -> OutputDto;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class OutputDto {
        self_type OutputDto;
        private constructor = empty;
        private fn OutputDto::to_string(&self) -> String; alias to_string;
        fn OutputDto::kind(&self) -> OutputKind;
        fn OutputDto::as_signature_locked_single_output_dto(&self) -> Result<SignatureLockedSingleOutputDto>;
        fn OutputDto::as_signature_locked_dust_allowance_output_dto(&self) -> Result<SignatureLockedDustAllowanceOutputDto>;
        fn OutputDto::as_treasury_output(&self) -> Result<TreasuryOutputDto>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class OutputsOptions {
        self_type OutputsOptions;
        constructor OutputsOptions::default() -> OutputsOptions;
        private fn OutputsOptions::to_string(&self) -> String; alias to_string;
        private fn OutputsOptions::include_spent(&mut self, include_spent: bool);
        private fn OutputsOptions::output_type(&mut self, output_type: Option<OutputKind>);
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class UtxoInput {
        self_type UtxoInput;
        private constructor = empty;
        private fn UtxoInput::to_string(&self) -> String; alias to_string;
        private fn UtxoInput::transaction_id(&self) -> Vec<u8>;
        private fn UtxoInput::index(&self) -> u16;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class ReceiptDto {
        self_type ReceiptDto;
        private constructor = empty;
        private fn ReceiptDto::to_string(&self) -> String; alias to_string;
        private fn ReceiptDto::milestone_index(&self) -> u32;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class ReceiptPayloadDto {
        self_type ReceiptPayloadDto;
        private constructor = empty;
        private fn ReceiptPayloadDto::to_string(&self) -> String; alias to_string;
        fn ReceiptPayloadDto::kind(&self) -> u32;
        fn ReceiptPayloadDto::migrated_at(&self) -> u32;
        fn ReceiptPayloadDto::funds(&self) -> Vec<MigratedFundsEntryDto>;
        fn ReceiptPayloadDto::last(&self) -> bool;
    }
);

foreign_class!(
    #[derive(PartialEq, camelCaseAliases, Display)]
    class MilestoneResponse {
        self_type MilestoneResponse;
        private constructor = empty;
        private fn MilestoneResponse::to_string(&self) -> String; alias to_string;
        private fn MilestoneResponse::eq(&self, o: &MilestoneResponse) -> bool; alias rustEq;
        /// Milestone index.
        fn MilestoneResponse::index(&self) -> u32;
        /// Milestone message id
        fn MilestoneResponse::message_id(&self) -> MessageId;
        /// Milestone timestamp.
        fn MilestoneResponse::timestamp(&self) -> u64;
    }
);

foreign_class!(
    #[derive(PartialEq, camelCaseAliases, Display)]
    class MilestoneUtxoChangesResponse {
        self_type MilestoneUtxoChangesResponse;
        private constructor = empty;
        private fn MilestoneUtxoChangesResponse::to_string(&self) -> String; alias to_string;
        private fn MilestoneUtxoChangesResponse::eq(&self, o: &MilestoneUtxoChangesResponse) -> bool; alias rustEq;
        /// Milestone index.
        fn MilestoneUtxoChangesResponse::index(&self) -> u32;
        /// Milestone message id
        fn MilestoneUtxoChangesResponse::created_outputs(&self) -> Vec<String>;
        /// Milestone timestamp.
        fn MilestoneUtxoChangesResponse::consumed_outputs(&self) -> Vec<String>;
    }
);

foreign_class!(
    class SignatureLockedSingleOutputDto {
        self_type SignatureLockedSingleOutputDto;
        private constructor = empty;
        fn SignatureLockedSingleOutputDto::amount(&self) -> u64;
    }
);

foreign_class!(
    class SignatureLockedDustAllowanceOutputDto {
        self_type SignatureLockedDustAllowanceOutputDto;
        private constructor = empty;
        fn SignatureLockedDustAllowanceOutputDto::amount(&self) -> u64;
    }
);

foreign_class!(
    class TreasuryOutputDto {
        self_type TreasuryOutputDto;
        private constructor = empty;
        fn TreasuryOutputDto::amount(&self) -> u64;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
        class PeerDto {
        self_type PeerDto;
        private constructor = empty;
        fn PeerDto::id(&self) -> &str;
        fn PeerDto::multi_addresses(&self) -> Vec<String>;
        fn PeerDto::alias(&self) -> Option<String>;
        fn PeerDto::relation(&self) -> Relation;
        fn PeerDto::connected(&self) -> bool;
        fn PeerDto::gossip(&self) -> Option<GossipDto>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class GossipDto {
        self_type GossipDto;
        private constructor = empty;
        fn GossipDto::heartbeat(&self) -> HeartbeatDto;
        fn GossipDto::metrics(&self) -> MetricsDto;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class HeartbeatDto {
    self_type HeartbeatDto;
        private constructor = empty;
        fn HeartbeatDto::solid_milestone_index(&self) -> u32;
        fn HeartbeatDto::pruned_milestone_index(&self) -> u32;
        fn HeartbeatDto::latest_milestone_index(&self) -> u32;
        fn HeartbeatDto::connected_neighbors(&self) -> u8;
        fn HeartbeatDto::synced_neighbors(&self) -> u8;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class MetricsDto {
        self_type MetricsDto;
        private constructor = empty;
        fn MetricsDto::new_messages(&self) -> u64;
        fn MetricsDto::received_messages(&self) -> u64;
        fn MetricsDto::known_messages(&self) -> u64;
        fn MetricsDto::received_message_requests(&self) -> u64;
        fn MetricsDto::received_milestone_requests(&self) -> u64;
        fn MetricsDto::received_heartbeats(&self) -> u64;
        fn MetricsDto::sent_messages(&self) -> u64;
        fn MetricsDto::sent_message_requests(&self) -> u64;
        fn MetricsDto::sent_milestone_requests(&self) -> u64;
        fn MetricsDto::sent_heartbeats(&self) -> u64;
        fn MetricsDto::dropped_packets(&self) -> u64;
    }
);

foreign_class!(
    class MigratedFundsEntryDto {
        self_type MigratedFundsEntryDto;
        private constructor = empty;
        fn MigratedFundsEntryDto::tail_transaction_hash(&self) -> &str;
        fn MigratedFundsEntryDto::address(&self) -> AddressDto;
        fn MigratedFundsEntryDto::deposit(&self) -> u64;
    }
);


/////////////// Message
foreign_class!(
    #[derive(Display)]
    class MessageWrap {
        self_type MessageWrap;
        private constructor = empty;
        private fn MessageWrap::to_string(&self) -> String; alias to_string;
        fn MessageWrap::message_id(&self) -> MessageId;
        fn MessageWrap::message(&self) -> Message;
    }
);

foreign_class!(
    #[derive(Display)]
    class MessageId {
        self_type MessageId;
        constructor MessageId::null() -> MessageId;
        private fn MessageId::to_string(&self) -> String; alias to_string;
        fn MessageId::fromString(str_rep: &str) -> MessageId {
            MessageId::from_str(str_rep).unwrap()
        }
    }
);

foreign_class!(
    #[derive(Display)]
    class Message {
        self_type Message;
        private constructor = empty;
        private fn Message::to_string(&self) -> String; alias to_string;
        fn Message::builder() -> MessageBuilder;
        fn Message::network_id(&self) -> u64;
        fn Message::id(&self) -> MessageId;
        fn Message::nonce(&self) -> u64;
        fn Message::parents(&self) -> Vec<MessageId>;
        // fn Message::payload(&self) -> Payload;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class MessageBuilder {
        self_type MessageBuilder;
        constructor MessageBuilder::new() -> MessageBuilder;
        fn MessageBuilder::network_id(&self, network_id: u64) -> MessageBuilder;
        //fn MessageBuilder::parents(&self, parents: Vec<MessageId>) -> MessageBuilder;
        //fn MessageBuilder::payload(&self payload: Payload) -> MessageBuilder;
        //fn MessageBuilder::nonce_provider(&self) -> MessageBuilder;
        fn MessageBuilder::finish(&self) -> Result<Message>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class ClientMessageBuilder {
        self_type ClientMessageBuilder<'a>;
        private constructor = empty;
        /// Sets the seed.
        fn ClientMessageBuilder::with_seed(&self, seed: &str) -> ClientMessageBuilder;

        /// Sets the account index.
        fn ClientMessageBuilder::with_account_index(&self, account_index: usize) -> ClientMessageBuilder;

        /// Sets the index of the address to start looking for balance.
        fn ClientMessageBuilder::with_initial_address_index(&self, initial_address_index: usize) -> ClientMessageBuilder;

        /// Set a custom input(transaction output)
        fn ClientMessageBuilder::with_input(&self, input: UtxoInput) -> ClientMessageBuilder;

        /// Set a custom range in which to search for addresses for custom inputs. Default: 0..100
        fn ClientMessageBuilder::with_input_range(&self, low: usize, high: usize) -> ClientMessageBuilder;

        /// 
        fn ClientMessageBuilder::with_output(&self, address: &str, amount: u64) -> Result<ClientMessageBuilder>;

        /// Set a dust allowance transfer to the builder, address needs to be Bech32 encoded
        fn ClientMessageBuilder::with_dust_allowance_output(&self, address: &str, amount: u64)  -> Result<ClientMessageBuilder>;

        /// Set a transfer to the builder, address needs to be hex encoded
        fn ClientMessageBuilder::with_output_hex(&self, address: &str, amount: u64)  -> Result<ClientMessageBuilder>;

        /// Set indexation to the builder
        fn ClientMessageBuilder::with_index_vec(&self, index: Vec<u8>)  -> ClientMessageBuilder;
        /// Set indexation to the builder
        fn ClientMessageBuilder::with_index_string(&self, index: &str)  -> ClientMessageBuilder;

        /// Set data to the builder
        fn ClientMessageBuilder::with_data(&self, data: Vec<u8>)  -> ClientMessageBuilder;

        /// Consume the builder and return the message
        fn ClientMessageBuilder::finish(&self) -> Result<Message>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class GetMessageBuilder {
        self_type GetMessageBuilder<'a>;
        private constructor = empty;
        
        /// GET /api/v1/messages?index={Index} endpoint
        /// Consume the builder and search for messages matching the index
        fn GetMessageBuilder::index_string(&self, index: &str) -> Result<Vec<MessageId>>;

        /// GET /api/v1/messages?index={Index} endpoint
        /// Consume the builder and search for messages matching the index
        fn GetMessageBuilder::index_vec(&self, index: Vec<u8>) -> Result<Vec<MessageId>>;

        /// GET /api/v1/messages/{messageID} endpoint
        /// Consume the builder and find a message by its identifer. This method returns the given message object.
        fn GetMessageBuilder::data(&self, message_id: MessageId) -> Result<Message>;

        /// GET /api/v1/messages/{messageID}/metadata endpoint
        /// Consume the builder and find a message by its identifer. This method returns the given message metadata.
        fn GetMessageBuilder::metadata(&self, message_id: MessageId) -> Result<MessageMetadata>;

        /// GET /api/v1/messages/{messageID}/raw endpoint
        /// Consume the builder and find a message by its identifer. This method returns the given message raw data.
        fn GetMessageBuilder::raw(&self, message_id: MessageId) -> Result<String>;

        /// GET /api/v1/messages/{messageID}/children endpoint
        /// Consume the builder and returns the list of message IDs that reference a message by its identifier.
        fn GetMessageBuilder::children(&self, message_id: MessageId) -> Result<Vec<MessageId>>;
    }
);

foreign_class!(
    /// Response of GET /api/v1/messages/{message_id}/metadata.
    /// Returns the metadata of a message.
    #[derive(camelCaseAliases, Display)]
    class MessageMetadata {
        self_type MessageMetadata;
        private constructor = empty;
        private fn MessageMetadata::to_string(&self) -> String; alias to_string;
        fn MessageMetadata::message_id(&self) -> &str;
        fn MessageMetadata::parent_message_ids(&self) -> Vec<String>;
        fn MessageMetadata::is_solid(&self) -> bool;
        fn MessageMetadata::referenced_by_milestone_index(&self) -> Option<u32>;
        fn MessageMetadata::milestone_index(&self) -> Option<u32>;
        fn MessageMetadata::ledger_inclusion_state(&self) -> Option<LedgerInclusionStateDto>;
        fn MessageMetadata::conflict_reason(&self) -> Option<u8>;
        fn MessageMetadata::should_promote(&self) -> Option<bool>;
        fn MessageMetadata::should_reattach(&self) -> Option<bool>;
    }
);

/////////////// Address

foreign_class!(
    #[derive(Display)]
    class Address {
        self_type Address;
        private constructor = empty;
        fn Address::try_from_bech32(addr: &str) -> Result<Address>;
        private fn Address::to_string(&self) -> String; alias to_string;
    }
);

foreign_class!(
    class AddressDto {
        self_type AddressDto;
        private constructor = empty;
        fn AddressDto::kind(&self) -> u8;
        fn AddressDto::address(&self) -> &str;
    }
);

foreign_class!(
    class GetBalanceBuilderApi {
        self_type GetBalanceBuilderApi<'a>;
        private constructor = empty;
        
        /// Sets the account index.
        fn GetBalanceBuilderApi::with_account_index(&self, account_index: usize) -> GetBalanceBuilderApi;

        /// Sets the index of the address to start looking for balance.
        fn GetBalanceBuilderApi::with_initial_address_index(&self, initial_address_index: usize) -> GetBalanceBuilderApi;
        
        /// Sets the gap limit to specify how many addresses will be checked each round.
        /// If gap_limit amount of addresses in a row have no balance the function will return.
        fn GetBalanceBuilderApi::with_gap_limit(&self, gap_limit: usize) -> GetBalanceBuilderApi;
        
        /// Consume the builder and get the API result
        fn GetBalanceBuilderApi::finish(&self) -> Result<u64>;
    }
);

foreign_class!(
    class GetAddressBuilderNode {
        self_type GetAddressBuilderNode<'a>;
        private constructor = empty;
        fn GetAddressBuilderNode::balance(&self, address: &str) -> Result<BalanceAddressResponse>;
        fn GetAddressBuilderNode::outputs(&self, address: &str, options: OutputsOptions) -> Result<Vec<UtxoInput>>;
    }
);

foreign_class!(
    class GetAddressesBuilderApi {
        self_type GetAddressesBuilderApi;
        constructor GetAddressesBuilderApi::new(seed: &str) -> GetAddressesBuilderApi;
        
        /// Set the account index
        fn GetAddressesBuilderApi::with_account_index(&self, account_index: usize) -> GetAddressesBuilderApi;
        
        /// Set range to the builder
        fn GetAddressesBuilderApi::with_range(&self, start: usize, end: usize) -> GetAddressesBuilderApi;
        
        /// Set bech32 human readable part (hrp)
        fn GetAddressesBuilderApi::with_bech32_hrp(&self, bech32_hrp: String) -> GetAddressesBuilderApi;
        
        /// Set client to the builder
        fn GetAddressesBuilderApi::with_client(&self, client: Client) -> GetAddressesBuilderApi;
        
        
        fn GetAddressesBuilderApi::finish(&self) -> Result<Vec<String>>;
    }
);

//////////////// Util
foreign_class!(class RustHex {
    fn hex::encode(_ : String) -> String;
    fn hex::encode(_ : Vec<u8>) -> String;
    fn decode(s : String) -> Result<Vec<u8>> {
        let res = hex::decode(s);
        match res {
            Ok(s) => Ok(s),
            Err(e) => Err(anyhow!("Hex error {:?}", e.to_string()))
        }
    }
    fn decode(s : Vec<u8>) -> Result<Vec<u8>> {
        let res = hex::decode(s);
        match res {
            Ok(s) => Ok(s),
            Err(e) => Err(anyhow!("Hex error {:?}", e.to_string()))
        }
    }
});

foreign_class!(
    #[derive(camelCaseAliases)]
    class Signature {
        self_type Signature;
        private constructor = empty;
        fn Signature::to_bytes(&self) -> Vec<u8>;
        fn Signature::from_bytes(bs: Vec<u8>) -> Signature;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class PublicKey {
        self_type PublicKey;
        private constructor = empty;
        fn PublicKey::verify(&self, sig: Signature, msg: Vec<u8>) -> bool;
        fn PublicKey::to_compressed_bytes(&self) -> Vec<u8>;
        fn PublicKey::from_compressed_bytes(bs: Vec<u8>) -> Result<PublicKey>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class SecretKey {
        self_type SecretKey;
        private constructor = empty;
        fn SecretKey::generate() -> Result<SecretKey>;
        fn SecretKey::from_le_bytes(bs: Vec<u8>) -> Result<SecretKey>;
        
        fn SecretKey::public_key(&self) -> PublicKey;
        fn SecretKey::to_le_bytes(&self) -> Vec<u8>;
        fn SecretKey::sign(&self, msg: Vec<u8>) -> Signature;
    }
);

/*
foreign_enum!(
    enum InputKind {
        UTXO = InputKind::Utxo,
        TREASURY = InputKind::Treasury,
    }
);
foreign_enum!(
    enum UnlockBlockKind {
        ED25519 = UnlockBlockKind::Ed25519,
        REFERENCE = UnlockBlockKind::Reference,
    }
);*/

/*
foreign_enum!(
    enum MessageType {
        RECEIVED = MessageType::Received,
        SENT = MessageType::Sent,
        FAILED = MessageType::Failed,
        UNCONFIRMED = MessageType::Unconfirmed,
        VALUE = MessageType::Value,
        CONFIRMED = MessageType::Confirmed,
    }
);

foreign_enum!(
    enum MessagePayloadType {
        TRANSACTION = MessagePayloadType::Transaction,
        MILESTONE = MessagePayloadType::Milestone,
        INDEXATION = MessagePayloadType::Indexation,
        RECEIPT = MessagePayloadType::Receipt,
        TREASURY_TRANSACTION = MessagePayloadType::TreasuryTransaction,
    }
);

foreign_enum!(
    enum ValueUnit {
        I = ValueUnit::I,
        Ki = ValueUnit::Ki,
        Mi = ValueUnit::Mi,
        Gi = ValueUnit::Gi,
        Ti = ValueUnit::Ti,
        Pi = ValueUnit::Pi,
    }
);

foreign_enum!(
    enum InputKind {
        UTXO = InputKind::UTXO,
        TREASURY = InputKind::Treasury,
    }
);
foreign_enum!(
    enum UnlockBlockKind {
        ED25519 = UnlockBlockKind::Ed25519,
        REFERENCE = UnlockBlockKind::Reference,
    }
);

foreign_class!(class ClientOptionsBuilder {
    self_type ClientOptionsBuilder;
    constructor ClientOptionsBuilder::new() -> ClientOptionsBuilder;
    fn ClientOptionsBuilder::with_node(&mut self, node: &str) -> ClientOptionsBuilder; alias withNode;
    fn ClientOptionsBuilder::with_node_pool_urls(&mut self, node_pool_urls: Vec<String>) -> ClientOptionsBuilder; alias withNodePoolUrls;
    fn ClientOptionsBuilder::with_network(&mut self, network: String) -> ClientOptionsBuilder; alias withNetwork;
    fn ClientOptionsBuilder::with_node_sync_interval(&mut self, node_sync_interval: Duration) -> ClientOptionsBuilder; alias withNodeSyncInterval;
    fn ClientOptionsBuilder::with_node_sync_disabled(&mut self) -> ClientOptionsBuilder; alias withNodeSyncDisabled;
    fn ClientOptionsBuilder::with_mqtt_mqtt_broker_options(&mut self, options: BrokerOptions) -> ClientOptionsBuilder; alias withMqttBrokerOptions;
    fn ClientOptionsBuilder::with_local_pow(&mut self, local: bool) -> ClientOptionsBuilder; alias withLocalPow;
    fn ClientOptionsBuilder::with_request_timeout(&mut self, timeout: Duration) -> ClientOptionsBuilder; alias withRequestTimeout;
    fn ClientOptionsBuilder::with_api_timeout(&mut self, api: Api, timeout: Duration) -> ClientOptionsBuilder; alias withApiTimeout;
    fn ClientOptionsBuilder::build(&mut self) -> Result<ClientOptions>;
});

foreign_class!(class ClientOptions {
    self_type ClientOptions;
    private constructor = empty;
});

foreign_class!(
    #[derive(Display)]
    class Value {
        self_type Value;
        constructor Value::new(value: u64, unit: ValueUnit) -> Value;
        private fn Value::with_denomination(&self) -> String; alias to_string;
        fn Value::with_denomination(&self) -> String; alias withDenomination;
        fn Value::without_denomination(&self) -> u64; alias withoutDenomination;
        fn Value::value(&self) -> &u64;
    }
);


foreign_class!(
    #[derive(PartialEq)]
    class Message {
        self_type Message;
        private constructor = empty;
        private fn Message::eq(&self, o: &Message) -> bool; alias rustEq;
        fn Message::id(&self) -> MessageId;
        fn Message::version(&self) -> u64;
        fn Message::parents(&self) -> Vec<MessageId>;
        fn Message::payload_length(&self) -> usize; alias payloadLength;
        fn Message::payload(&self) -> Option<MessagePayload>;
        fn Message::timestamp(&self) -> DateTime<Utc>;
        fn Message::nonce(&self) -> u64;
        fn Message::confirmed(&self) -> Option<bool>;
        fn Message::broadcasted(&self) -> bool;
    }
);

foreign_class!(
    #[derive(PartialEq, Display)]
    class Address {
        self_type Address;
        private constructor = empty;
        private fn Address::eq(&self, o: &Address) -> bool; alias rustEq;
        private fn Address::to_string(&self) -> String;
        fn Address::balance(&self) -> u64; alias getBalance;
        fn Address::readable(&self) -> String; alias getReadable;
        fn Address::address(&self) -> AddressWrapper;
    }
);

foreign_class!(
    class AddressWrapper {
        self_type AddressWrapper;
        private constructor = empty;
        fn AddressWrapper::from(address: &str, bech32_hrp: String) -> Result<AddressWrapper> {
            match IotaAddress::try_from_bech32(address) {
                Ok(addr) => Ok(AddressWrapper::new(addr, bech32_hrp)),
                Err(e) => Err(anyhow!(e)),
            }
        }
        fn AddressWrapper::to_bech32(&self) -> String; alias toBech32;
    }
);

// Bee types wrapping
foreign_class!(
    #[derive(Display)]
    class MessagePayload {
        self_type MessagePayload;
        private constructor = empty;
        private fn MessagePayload::to_string(&self) -> String;
        fn MessagePayload::payload_type(&self) -> MessagePayloadType; alias payloadType;
        fn MessagePayload::get_as_indexation(&self) -> Option<IndexationPayload>; alias getAsIndexation;
        fn MessagePayload::get_as_milestone(&self) -> Option<MilestonePayload>; alias getAsMilestone;
    }
);

foreign_class!(
    class IndexationPayload {
        self_type IndexationPayload;
        private constructor = empty;
        fn IndexationPayload::new(index: &[u8], data: &[u8]) -> Result<IndexationPayload>; alias new_with;
        fn IndexationPayload::index(&self) -> &[u8];
        fn IndexationPayload::data(&self) -> &[u8];
    }
);

foreign_class!(
    class MilestonePayload {
        self_type MilestonePayload;
        private constructor = empty;
        fn MilestonePayload::id(&self) -> String;
        fn MilestonePayload::essence(&self) -> MilestonePayloadEssence;
        fn MilestonePayload::validate(&self, applicable_public_keys: &[String], min_threshold: usize) -> bool;
        //fn MilestonePayload::signatures(&self) -> Vec<Box<[u8]>>;
    }
);

foreign_class!(
    class MilestonePayloadEssence {
        self_type MilestonePayloadEssence;
        private constructor = empty;
        fn MilestonePayloadEssence::index(&self) -> u32;
        fn MilestonePayloadEssence::timestamp(&self) -> u64;
        fn MilestonePayloadEssence::parents(&self) -> Vec<MessageId>;
        fn MilestonePayloadEssence::merkle_proof(&self) -> Vec<u8>; alias merkleProof;
    }
);

// TransactionEssence

foreign_class!(
    class MessageTransactionPayload {
        self_type MessageTransactionPayload;
        private constructor = empty;
        fn MessageTransactionPayload::essence(&self) -> Essence;
        fn MessageTransactionPayload::unlock_blocks(&self) -> Vec<UnlockBlock>; alias unlockBlocks;
    }
);

foreign_class!(
    class Essence {
        self_type Essence;
        private constructor = empty;
        fn Essence::get_as_regular(&self) -> Option<RegularEssence>; alias getAsRegular;
    }
);

foreign_class!(
    class RegularEssence {
        self_type RegularEssence;
        private constructor = empty;
        fn RegularEssence::inputs(&self) -> Vec<TransactionInput>;
        fn RegularEssence::outputs(&self) -> Vec<TransactionOutput>;
        fn RegularEssence::internal(&self) -> bool;
    
        fn RegularEssence::incoming(&self) -> bool;
    
        /// The transactions's value.
        fn RegularEssence::value(&self) -> u64;
    
        /// The transactions's remainder value sum.
        fn RegularEssence::remainder_value(&self) -> u64; alias remainderValue;
    }
);

foreign_class!(
    #[derive(Display)]
    class TransactionInput {
        self_type TransactionInput;
        private constructor = empty;
        private fn TransactionInput::to_string(&self) -> String;
        fn TransactionInput::kind(&self) -> InputKind;
    }
);

foreign_class!(
    #[derive(Display)]
    class TransactionOutput {
        self_type TransactionOutput;
        private constructor = empty;
        private fn TransactionOutput::to_string(&self) -> String;
        fn TransactionOutput::kind(&self) -> OutputKind;
    }
);

foreign_class!(
    #[derive(Display)]
    class UnlockBlock {
        self_type UnlockBlock;
        private constructor = empty;
        private fn UnlockBlock::to_string(&self) -> String;
        fn UnlockBlock::kind(&self) -> UnlockBlockKind;
    }
);

foreign_class!(
    class TreasuryTransactionPayload {
        self_type TreasuryTransactionPayload;
        private constructor = empty;
        fn TreasuryTransactionPayload::input(&self) -> MessageId;
        fn TreasuryTransactionPayload::output(&self) -> u64;
    }
);
*/