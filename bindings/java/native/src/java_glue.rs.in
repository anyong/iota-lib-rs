use std::{
    time::Duration,
    str::FromStr,
};

use crate::{
    client_builder::*,
    full_node_api::*,
    balance::*,
    jni_c_header::*,
    bee_types::*,
    message::*,
    prepared::*,
    address::*,
    ed25519::*,
    slip10::*,
    mqtt::*,
};
use iota_client::{
    TopicEvent, MqttEvent, node::Topic,
    Api, bee_message::{
        payload::{
            milestone::MilestoneId,
            transaction::TransactionId,
        },
        MessageId,
    },
    bee_rest_api::types::dtos::LedgerInclusionStateDto,
};
use anyhow::{
    anyhow,
    Result,
};


foreign_class!(class RustLogging {
    fn init() {
        env_logger::init();
    }
});

foreign_enum!(
    enum Api {
        /// `get_health` API
        GET_HEALTH = Api::GetHealth,
        /// `get_info`API
        GET_INFO = Api::GetInfo,
        /// `get_peers`API
        GET_PEERS = Api::GetPeers,
        /// `get_tips` API
        GET_TIPS = Api::GetTips,
        /// `post_message` API
        POST_MESSAGE = Api::PostMessage,
        /// `post_message` API with remote pow
        POST_MESSAGE_WITH_REMOTE_POW= Api::PostMessageWithRemotePow,
        /// `get_output` API
        GET_OUTPUT = Api::GetOutput,
        /// `get_milestone` API
        GET_MILESTONE = Api::GetMilestone,
        /// `get_message` API
        GET_MESSAGE  = Api::GetMessage,
        /// `get_balance` API
        GET_BALANCE = Api::GetBalance,
    }
);

foreign_enum!(
    enum Relation {
        KNOWN = Relation::KNOWN,
        UNKNOWN = Relation::UNKNOWN,
        AUTOPEERED = Relation::AUTOPEERED,
    }
);

foreign_enum!(
    enum OutputKind {
        SIGNATURE_LOCKED_SINGLE = OutputKind::SignatureLockedSingle,
        SIGNATURE_LOCKED_DUST_ALLOWANCE = OutputKind::SignatureLockedDustAllowance,
        TREASURY = OutputKind::Treasury,
    }
);

foreign_enum!(
    enum LedgerInclusionStateDto {
        CONFLICTING = LedgerInclusionStateDto::Conflicting,
        INCLUDED = LedgerInclusionStateDto::Included,
        NO_TRANSACTION = LedgerInclusionStateDto::NoTransaction,
    }
);

foreign_enum!(
    enum MessagePayloadType {
        TRANSACTION = MessagePayloadType::Transaction,
        MILESTONE = MessagePayloadType::Milestone,
        INDEXATION = MessagePayloadType::Indexation,
        RECEIPT = MessagePayloadType::Receipt,
        TREASURY_TRANSACTION = MessagePayloadType::TreasuryTransaction,
    }
);

foreign_enum!(
    enum InputKind {
        UTXO = InputKind::Utxo,
        TREASURY = InputKind::Treasury,
    }
);
foreign_enum!(
    enum UnlockBlockKind {
        ED25519 = UnlockBlockKind::Ed25519,
        REFERENCE = UnlockBlockKind::Reference,
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class BrokerOptions {
        self_type BrokerOptions;
        constructor BrokerOptions::new() -> BrokerOptions;
        fn BrokerOptions::automatic_disconnect(&self, disconnect: bool) -> BrokerOptions;
        fn BrokerOptions::timeout(&self, timeout: Duration) -> BrokerOptions;
        fn BrokerOptions::max_reconnection_attempts(&self, max_reconnection_attempts: usize) -> BrokerOptions;
        fn BrokerOptions::use_ws(&self, use_ws: bool) -> BrokerOptions;
        fn BrokerOptions::port(&self, port: u16) -> BrokerOptions;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class ClientBuilder {
        self_type ClientBuilder;
        constructor ClientBuilder::new() -> ClientBuilder;
        /// Adds an IOTA node by its URL.
        fn ClientBuilder::with_node(&mut self, node: &str) -> ClientBuilder;
        /// Adds a list of IOTA nodes by their URLs.
        fn ClientBuilder::with_nodes(&mut self, nodes: Vec<String>) -> ClientBuilder;
        /// Adds an IOTA node by its URL with optional jwt and or basic authentication
        fn ClientBuilder::with_node_auth(&mut self, node: &str, jwt: Option<&str>, username: Option<&str>, password: Option<&str>) -> ClientBuilder;
        /// Adds an IOTA node by its URL to be used as primary node, with optional jwt and or basic authentication
        fn ClientBuilder::with_primary_node(&mut self, node: &str, jwt: Option<&str>, username: Option<&str>, password: Option<&str>) -> ClientBuilder;
        /// Adds an IOTA node by its URL to be used as primary PoW node (for remote PoW), with optional jwt and or basic
        /// authentication
        fn ClientBuilder::with_primary_pow_node(&mut self, node: &str, jwt: Option<&str>, username: Option<&str>, password: Option<&str>) -> ClientBuilder;
        /// Adds an IOTA permanode by its URL, with optional jwt and or basic authentication
        fn ClientBuilder::with_permanode(&mut self, node: &str, jwt: Option<&str>, username: Option<&str>, password: Option<&str>) -> ClientBuilder;
        /// Get node list from the node_pool_urls
        fn ClientBuilder::with_node_pool_urls(&mut self, node_pool_urls: Vec<String>) -> ClientBuilder;
        /// Allows creating the client without nodes for offline address generation or signing
        fn ClientBuilder::with_offline_mode(&mut self) -> ClientBuilder;
        /// Selects the type of network to get default nodes for it, only "testnet" is supported at the moment.
        /// Nodes that don't belong to this network are ignored. Default nodes are only used when no other nodes are
        /// provided.
        fn ClientBuilder::with_network(&mut self, network: String) -> ClientBuilder;
        /// Set the node sync interval
        fn ClientBuilder::with_node_sync_interval(&mut self, node_sync_interval: Duration) -> ClientBuilder;
        /// Disables the node syncing process.
        /// Every node will be considered healthy and ready to use.
        fn ClientBuilder::with_node_sync_disabled(&mut self) -> ClientBuilder;

        /// Set if quroum should be used or not
        fn ClientBuilder::with_quorum(&self, quorum: bool) -> ClientBuilder;
        /// Set amount of nodes which should be used for quorum
        fn ClientBuilder::with_min_quorum_size(&self, min_quorum_size: usize) -> ClientBuilder;
        /// Set quorum_threshold
        fn ClientBuilder::with_quorum_threshold(&self, threshold: usize) -> ClientBuilder;

        /// Sets the MQTT broker options.
        fn ClientBuilder::with_mqtt_broker_options(&mut self, options: BrokerOptions) -> ClientBuilder;
        /// Sets whether the PoW should be done locally or remotely.
        fn ClientBuilder::with_local_pow(&mut self, local: bool) -> ClientBuilder;
        /// Sets after how many seconds new tips will be requested during PoW
        fn ClientBuilder::with_tips_interval(&mut self, tips: u64) -> ClientBuilder;
        /// Sets the default request timeout in seconds.
        fn ClientBuilder::with_api_timeout(&mut self, timeout: Duration) -> ClientBuilder;
        /// Sets the request timeout in seconds for a specific API usage.
        fn ClientBuilder::with_api_timeout(&mut self, api: Api, timeout: Duration) -> ClientBuilder;
        /// Build the Client instance.
        fn ClientBuilder::finish(&mut self) -> Result<Client>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class Client {
        self_type Client;
        private constructor = empty;
        fn Client::builder() -> ClientBuilder; alias Builder;

        /// GET /health endpoint
        fn Client::get_health(&self) -> Result<bool>;

        /// GET /health endpoint for the passed node
        fn Client::get_node_health(&self, node: &str) -> Result<bool>;

        /// GET /api/v2/info endpoint
        fn Client::get_info(&self) -> Result<NodeInfoWrapper>;

        /// GET /api/v2/peers endpoint
        fn Client::get_peers(&self) -> Result<Vec<PeerDto>>;

        /// GET /api/v2/tips endpoint
        fn Client::get_tips(&self) -> Result<Vec<String>>;

        /// GET /api/v2/outputs/{outputId} endpoint
        /// Find an output by its transaction_id and corresponding output_index.
        fn Client::get_output(&self, output_id: String) -> Result<OutputResponse>;

        /// GET /api/plugins/indexer/v1/outputs/basic{query} endpoint
        fn Client::get_address(&self) -> GetAddressBuilder;

        /// Return the balance in iota for the given address; No seed needed to do this
        /// since we are only checking and already know the address.
        fn Client::get_address_balance(&self, address: &str) -> Result<BalanceAddressResponse>;

        // Return the balance in iota for the given addresses; No seed needed to do this
        /// since we are only checking and already know the addresses.
        fn Client::get_addresses_balances(&self, addresses: Vec<String>) -> Result<Vec<BalanceAddressResponse>>;

        /// Find all outputs based on the requests criteria. This method will try to query multiple nodes if
        /// the request amount exceeds individual node limit.
        fn Client::find_outputs(&self, output_ids: Option<Vec<String>>, addresses: Option<Vec<String>>) -> Result<Vec<OutputResponse>>;

        /// GET /api/v2/milestones/{index} endpoint
        /// Get the milestone by the given index.
        fn Client::get_milestone(&self, index: u32) -> Result<MilestoneResponse>;

        /// GET /api/v2/milestones/{index}/utxo-changes endpoint
        /// Gets the utxo changes by the given milestone index.
        fn Client::get_milestone_utxo_changes(&self, index: u32) -> Result<MilestoneUtxoChangesResponse>;

        /// GET /api/v2/receipts endpoint
        /// Get all receipts.
        fn Client::get_receipts(&self) -> Result<Vec<ReceiptDto>>;

        /// GET /api/v2/receipts/{migratedAt} endpoint
        /// Get the receipts by the given milestone index.
        fn Client::get_receipts_migrated_at(&self, index: u32) -> Result<Vec<ReceiptDto>>;

        /// GET /api/v2/treasury endpoint
        /// Get the treasury output.
        fn Client::get_treasury(&self) -> Result<TreasuryResponse>;

        /// GET /api/v2/transactions/{transactionId}/included-message
        /// Returns the included message of the transaction.
        fn Client::get_included_message(&self, transaction_id: TransactionId) -> Result<Message>;

        /// POST /api/v2/messages endpoint
        fn Client::post_message(&self, msg: Message) -> Result<MessageId>;

        /// Reattaches messages for provided message id. Messages can be reattached only if they are valid and haven't been
        /// confirmed for a while.
        fn Client::reattach(&self, message_id: MessageId) -> Result<MessageWrap>;

        /// Reattach a message without checking if it should be reattached
        fn Client::reattach_unchecked(&self, message_id: MessageId) -> Result<MessageWrap>;

        /// Promotes a message. The method should validate if a promotion is necessary through get_message. If not, the
        /// method should error out and should not allow unnecessary promotions.
        fn Client::promote(&self, message_id: MessageId) -> Result<MessageWrap>;

        /// Promote a message without checking if it should be promoted
        fn Client::promote_unchecked(&self, message_id: MessageId) -> Result<MessageWrap>;

        /// Return the balance for a provided seed and its wallet chain account index.
        /// Addresses with balance must be consecutive, so this method will return once it encounters a zero
        /// balance address.
        fn Client::get_balance(&self, seed: &str) -> Result<GetBalanceBuilderApi>;

        /// A generic send function for easily sending transaction or indexation messages.
        fn Client::message(&self) -> ClientMessageBuilder;

        /// GET /api/v2/messages/{messageId} endpoint
        fn Client::get_message(&self) -> GetMessageBuilder;

        /// Return a list of addresses from the seed regardless of their validity.
        fn Client::get_addresses(&self, seed: &str) -> Result<GetAddressesBuilder>;

        /// Retries (promotes or reattaches) a message for provided message id until it's included (referenced by a
        /// milestone). Default interval is 5 seconds and max attempts is 40. Returns reattached messages. Set to -1 for defaults.
        fn Client::retry_until_included(&self, message_id: MessageId,
            interval: usize,
            max_attempts: usize) -> Result<Vec<MessageWrap>>;

        /// Returns a handle to the MQTT topics manager.
        fn Client::subscriber(&mut self) -> MqttManager;

        /// Generates a new mnemonic.
        fn Client::generate_mnemonic() -> Result<String>;

        /// Returns a hex encoded seed for a mnemonic.
        fn Client::mnemonic_to_hex_seed(mnemonic: &str) -> Result<String>;

        /// Function to find inputs from addresses for a provided amount (useful for offline signing)
        fn Client::find_inputs(&self, addresses: Vec<String>, amount: u64) -> Result<Vec<UtxoInput>>;

        /// Transforms bech32 to hex
        fn Client::bech32_to_hex(bech32: &str) -> Result<String>;
        /// Transforms hex to bech32
        fn Client::hex_to_bech32(&self, hex: &str, bech32_hrp: Option<&str>) -> Result<String>;
        /// Checks if a str is a valid bech32 encoded address.
        fn Client::is_address_valid(address: &str) -> bool;

        /// Returns a valid Address parsed from a String.
        fn Client::parse_bech32_address(address: &str) -> Result<Address>;

        /// Temporarily method to check if your seed is made using the incorrect generation of the old JAVA seed input
        /// @param seed The seed you used previously
        /// @param account_index The account index used, is 0 when you didnt use it
        /// @param address_index The address index you want to migrate
        /// @param pub_addr If it's a public or internal address
        fn Client::should_migrate(&self, seed: &str, account_index: usize, address_index: usize, pub_addr: bool) -> Result<bool>;

        /// Temporarily method in order to migrate wrongly generated seeds from JAVA to Rust
        /// Migrates the balance of the address towards the provided to_address
        /// And returns the message or an error
        /// @param seed The seed you used previously
        /// @param account_index The account index used, is 0 when you didnt use it
        /// @param address_index The address index you want to migrate
        /// @param pub_addr If it's a public or internal address
        /// @param to_address The address we send the balance to
        fn Client::migrate(&self, seed: &str, account_index: usize, address_index: usize, pub_addr: bool, to_address: &str) -> Result<Message>;
    }
);

foreign_class!(
    #[derive(PartialEq, camelCaseAliases, Display)]
    class NodeInfoWrapper {
        self_type NodeInfoWrapper;
        private constructor = empty;
        private fn NodeInfoWrapper::to_string(&self) -> String; alias to_string;
        private fn NodeInfoWrapper::eq(&self, o: &NodeInfoWrapper) -> bool; alias rustEq;
        fn NodeInfoWrapper::url(&self) -> &str;
        fn NodeInfoWrapper::nodeinfo(&self) -> InfoResponse; alias nodeInfo;
    }
);

foreign_class!(
    #[derive(PartialEq, camelCaseAliases, Display)]
    class InfoResponse {
        self_type InfoResponse;
        private constructor = empty;
        private fn InfoResponse::to_string(&self) -> String; alias to_string;
        private fn InfoResponse::eq(&self, o: &InfoResponse) -> bool; alias rustEq;
        fn InfoResponse::name(&self) -> &str;
        fn InfoResponse::version(&self) -> &str;
        fn InfoResponse::network_id(&self) -> &str;
        fn InfoResponse::bech32_hrp(&self) -> &str;
        fn InfoResponse::messages_per_second(&self) -> f64;
        fn InfoResponse::referenced_messages_per_second(&self) -> f64;
        fn InfoResponse::referenced_rate(&self) -> f64;
        fn InfoResponse::latest_milestone_timestamp(&self) -> u64;
        fn InfoResponse::min_pow_score(&self) -> f64;
        fn InfoResponse::latest_milestone_index(&self) -> u32;
        fn InfoResponse::confirmed_milestone_index(&self) -> u32;
        fn InfoResponse::pruning_index(&self) -> u32;
        fn InfoResponse::features(&self) -> Vec<String>;
    }
);

foreign_class!(
    #[derive(PartialEq, camelCaseAliases, Display)]
    class BalanceAddressResponse {
        self_type BalanceAddressResponse;
        private constructor = empty;
        private fn BalanceAddressResponse::to_string(&self) -> String; alias to_string;
        private fn BalanceAddressResponse::eq(&self, o: &BalanceAddressResponse) -> bool; alias rustEq;
        fn BalanceAddressResponse::address_type(&self) -> u8;
        fn BalanceAddressResponse::address(&self) -> &str;
        fn BalanceAddressResponse::balance(&self) -> u64;
        fn BalanceAddressResponse::dust_allowed(&self) -> bool;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class OutputResponse {
        self_type OutputResponse;
        private constructor = empty;
        private fn OutputResponse::to_string(&self) -> String; alias to_string;
        fn OutputResponse::message_id(&self) -> &str;
        fn OutputResponse::transaction_id(&self) -> &str;
        fn OutputResponse::output_index(&self) -> u16;
        fn OutputResponse::is_spent(&self) -> bool;
        fn OutputResponse::output(&self) -> OutputDto;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class OutputDto {
        self_type OutputDto;
        private constructor = empty;
        private fn OutputDto::to_string(&self) -> String; alias to_string;
        fn OutputDto::kind(&self) -> OutputKind;
        fn OutputDto::as_signature_locked_single_output_dto(&self) -> Result<SignatureLockedSingleOutputDto>;
        fn OutputDto::as_signature_locked_dust_allowance_output_dto(&self) -> Result<SignatureLockedDustAllowanceOutputDto>;
        fn OutputDto::as_treasury_output(&self) -> Result<TreasuryOutputDto>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class OutputsOptions {
        self_type OutputsOptions;
        constructor OutputsOptions::default() -> OutputsOptions;
        private fn OutputsOptions::to_string(&self) -> String; alias to_string;
        /// Whether the query should include spent outputs or not.
        fn OutputsOptions::include_spent(&mut self, include_spent: bool);
        /// The output type filter.
        fn OutputsOptions::output_type(&mut self, output_type: Option<OutputKind>);
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class UtxoInput {
        self_type UtxoInput;
        private constructor = empty;
        private fn UtxoInput::to_string(&self) -> String; alias to_string;
        fn UtxoInput::from(id: TransactionId, index: u16) -> Result<UtxoInput>;
        fn UtxoInput::transaction_id(&self) -> Vec<u8>;
        fn UtxoInput::index(&self) -> u16;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class TreasuryInput {
        self_type TreasuryInput;
        constructor TreasuryInput::new(milestone: MilestoneId) -> TreasuryInput;
        private fn TreasuryInput::to_string(&self) -> String; alias to_string;
        /// Returns the milestones id of a `TreasuryInput`.
        fn TreasuryInput::milestone_id(&self) -> MilestoneId;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class ReceiptDto {
        self_type ReceiptDto;
        private constructor = empty;
        private fn ReceiptDto::to_string(&self) -> String; alias to_string;
        fn ReceiptDto::milestone_index(&self) -> u32;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class ReceiptPayloadDto {
        self_type ReceiptPayloadDto;
        private constructor = empty;
        private fn ReceiptPayloadDto::to_string(&self) -> String; alias to_string;
        fn ReceiptPayloadDto::kind(&self) -> u32;
        fn ReceiptPayloadDto::migrated_at(&self) -> u32;
        fn ReceiptPayloadDto::funds(&self) -> Vec<MigratedFundsEntryDto>;
        fn ReceiptPayloadDto::last(&self) -> bool;
    }
);

foreign_class!(
    /// Response of GET /api/v2/treasury.
    /// Returns all information about the treasury.
    #[derive(PartialEq, camelCaseAliases, Display)]
    class TreasuryResponse {
        self_type TreasuryResponse;
        private constructor = empty;
        private fn TreasuryResponse::to_string(&self) -> String; alias to_string;
        private fn TreasuryResponse::eq(&self, o: &TreasuryResponse) -> bool; alias rustEq;
        fn TreasuryResponse::amount(&self) -> u64;
        fn TreasuryResponse::milestone_id(&self) -> &str;
    }
);

foreign_class!(
    #[derive(PartialEq, camelCaseAliases, Display)]
    class MilestoneResponse {
        self_type MilestoneResponse;
        private constructor = empty;
        private fn MilestoneResponse::to_string(&self) -> String; alias to_string;
        private fn MilestoneResponse::eq(&self, o: &MilestoneResponse) -> bool; alias rustEq;
        /// Milestone index.
        fn MilestoneResponse::index(&self) -> u32;
        /// Milestone message id
        fn MilestoneResponse::message_id(&self) -> MessageId;
        /// Milestone timestamp.
        fn MilestoneResponse::timestamp(&self) -> u64;
    }
);

foreign_class!(
    #[derive(PartialEq, camelCaseAliases, Display)]
    class MilestoneUtxoChangesResponse {
        self_type MilestoneUtxoChangesResponse;
        private constructor = empty;
        private fn MilestoneUtxoChangesResponse::to_string(&self) -> String; alias to_string;
        private fn MilestoneUtxoChangesResponse::eq(&self, o: &MilestoneUtxoChangesResponse) -> bool; alias rustEq;
        /// Milestone index.
        fn MilestoneUtxoChangesResponse::index(&self) -> u32;
        /// Milestone message id
        fn MilestoneUtxoChangesResponse::created_outputs(&self) -> Vec<String>;
        /// Milestone timestamp.
        fn MilestoneUtxoChangesResponse::consumed_outputs(&self) -> Vec<String>;
    }
);

foreign_class!(
    /// Describes a deposit to a single address which is unlocked via a signature.
    #[derive(camelCaseAliases, Display)]
    class SignatureLockedSingleOutputDto {
        self_type SignatureLockedSingleOutputDto;
        private constructor = empty;
        private fn SignatureLockedSingleOutputDto::to_string(&self) -> String; alias to_string;
        /// Returns the amount of a `SignatureLockedSingleOutputDto`.
        fn SignatureLockedSingleOutputDto::amount(&self) -> u64;
        /// Returns the address of a `SignatureLockedSingleOutputDto`.
        fn SignatureLockedSingleOutputDto::address(&self) -> AddressDto;
    }
);

foreign_class!(
    /// Output type for deposits that enables an address to receive dust outputs. It can be consumed as an input like a
    /// regular SigLockedSingleOutput.
    #[derive(camelCaseAliases, Display)]
    class SignatureLockedDustAllowanceOutputDto {
        self_type SignatureLockedDustAllowanceOutputDto;
        private constructor = empty;
        private fn SignatureLockedDustAllowanceOutputDto::to_string(&self) -> String; alias to_string;
        /// Returns the amount of a `SignatureLockedDustAllowanceOutputDto`.
        fn SignatureLockedDustAllowanceOutputDto::amount(&self) -> u64;
        /// Returns the address of a `SignatureLockedDustAllowanceOutputDto`.
        fn SignatureLockedDustAllowanceOutputDto::address(&self) -> AddressDto;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class TreasuryOutputDto {
        self_type TreasuryOutputDto;
        private constructor = empty;
        private fn TreasuryOutputDto::to_string(&self) -> String; alias to_string;
        fn TreasuryOutputDto::amount(&self) -> u64;
    }
);

foreign_class!(
    /// Describes a deposit to a single address which is unlocked via a signature.
    #[derive(camelCaseAliases, Display)]
    class SignatureLockedSingleOutput {
        self_type SignatureLockedSingleOutput;
        private constructor = empty;
        private fn SignatureLockedSingleOutput::to_string(&self) -> String; alias to_string;
        /// Creates a new `SignatureLockedSingleOutput`.
        fn SignatureLockedSingleOutput::from(address: Address, amount: u64) -> Result<SignatureLockedSingleOutput>;
        /// Returns the amount of a `SignatureLockedSingleOutput`.
        fn SignatureLockedSingleOutput::amount(&self) -> u64;
        /// Returns the address of a `SignatureLockedSingleOutput`.
        fn SignatureLockedSingleOutput::address(&self) -> Address;
    }
);

foreign_class!(
    /// Output type for deposits that enables an address to receive dust outputs. It can be consumed as an input like a
    /// regular SigLockedSingleOutput.
    #[derive(camelCaseAliases, Display)]
    class SignatureLockedDustAllowanceOutput {
        self_type SignatureLockedDustAllowanceOutput;
        private constructor = empty;
        private fn SignatureLockedDustAllowanceOutput::to_string(&self) -> String; alias to_string;
        /// Creates a new `SignatureLockedDustAllowanceOutput`.
        fn SignatureLockedDustAllowanceOutput::from(address: Address, amount: u64) -> Result<SignatureLockedDustAllowanceOutput>;
        /// Returns the amount of a `SignatureLockedDustAllowanceOutput`.
        fn SignatureLockedDustAllowanceOutput::amount(&self) -> u64;
        /// Returns the address of a `SignatureLockedDustAllowanceOutput`.
        fn SignatureLockedDustAllowanceOutput::address(&self) -> Address;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class TreasuryOutput {
        self_type TreasuryOutput;
        private constructor = empty;
        private fn TreasuryOutput::to_string(&self) -> String; alias to_string;
        fn TreasuryOutput::from(amount: u64) -> Result<TreasuryOutput>;
        /// Returns the amount of a `TreasuryOutput`.
        fn TreasuryOutput::amount(&self) -> u64;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    /// Describes a peer.
    class PeerDto {
        self_type PeerDto;
        private constructor = empty;
        fn PeerDto::id(&self) -> &str;
        fn PeerDto::multi_addresses(&self) -> Vec<String>;
        fn PeerDto::alias(&self) -> Option<String>;
        fn PeerDto::relation(&self) -> Relation;
        fn PeerDto::connected(&self) -> bool;
        fn PeerDto::gossip(&self) -> Option<GossipDto>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class GossipDto {
        self_type GossipDto;
        private constructor = empty;
        fn GossipDto::heartbeat(&self) -> HeartbeatDto;
        fn GossipDto::metrics(&self) -> MetricsDto;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class HeartbeatDto {
    self_type HeartbeatDto;
        private constructor = empty;
        fn HeartbeatDto::solid_milestone_index(&self) -> u32;
        fn HeartbeatDto::pruned_milestone_index(&self) -> u32;
        fn HeartbeatDto::latest_milestone_index(&self) -> u32;
        fn HeartbeatDto::connected_neighbors(&self) -> u8;
        fn HeartbeatDto::synced_neighbors(&self) -> u8;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class MetricsDto {
        self_type MetricsDto;
        private constructor = empty;
        fn MetricsDto::new_messages(&self) -> u64;
        fn MetricsDto::received_messages(&self) -> u64;
        fn MetricsDto::known_messages(&self) -> u64;
        fn MetricsDto::received_message_requests(&self) -> u64;
        fn MetricsDto::received_milestone_requests(&self) -> u64;
        fn MetricsDto::received_heartbeats(&self) -> u64;
        fn MetricsDto::sent_messages(&self) -> u64;
        fn MetricsDto::sent_message_requests(&self) -> u64;
        fn MetricsDto::sent_milestone_requests(&self) -> u64;
        fn MetricsDto::sent_heartbeats(&self) -> u64;
        fn MetricsDto::dropped_packets(&self) -> u64;
    }
);

foreign_class!(
    class MigratedFundsEntryDto {
        self_type MigratedFundsEntryDto;
        private constructor = empty;
        fn MigratedFundsEntryDto::tail_transaction_hash(&self) -> &str;
        fn MigratedFundsEntryDto::address(&self) -> AddressDto;
        fn MigratedFundsEntryDto::deposit(&self) -> u64;
    }
);


/////////////// Message
foreign_class!(
    #[derive(Display)]
    class MessageWrap {
        self_type MessageWrap;
        private constructor = empty;
        private fn MessageWrap::to_string(&self) -> String; alias to_string;
        fn MessageWrap::message_id(&self) -> MessageId;
        fn MessageWrap::message(&self) -> Message;
    }
);

foreign_class!(
    #[derive(Display)]
    class MessageId {
        self_type MessageId;
        constructor MessageId::null() -> MessageId;
        private fn MessageId::to_string(&self) -> String; alias to_string;
        fn MessageId::fromString(str_rep: &str) -> MessageId {
            MessageId::from_str(str_rep).unwrap()
        }
    }
);
foreign_class!(
    #[derive(Display)]
    class TransactionId {
        self_type TransactionId;
        private constructor = empty;
        private fn TransactionId::to_string(&self) -> String; alias to_string;
        fn TransactionId::fromString(str_rep: &str) -> TransactionId {
            TransactionId::from_str(str_rep).unwrap()
        }
    }
);
foreign_class!(
    #[derive(Display)]
    class MilestoneId {
        self_type MilestoneId;
        private constructor = empty;
        private fn MilestoneId::to_string(&self) -> String; alias to_string;
        fn MilestoneId::fromString(str_rep: &str) -> MilestoneId {
            MilestoneId::from_str(str_rep).unwrap()
        }
    }
);
foreign_class!(
    /// Represent the object that nodes gossip around the network.
    #[derive(Display, camelCaseAliases)]
    class Message {
        self_type Message;
        private constructor = empty;
        private fn Message::to_string(&self) -> String; alias to_string;
        /// Creates a new `MessageBuilder` to construct an instance of a `Message`.
        fn Message::builder() -> MessageBuilder;
        /// Returns the network id of a `Message`.
        fn Message::network_id(&self) -> u64;
        /// Computes the identifier of the message.
        fn Message::id(&self) -> MessageId;
        /// Returns the nonce of a `Message`.
        fn Message::nonce(&self) -> u64;
        /// Returns the parents of a `Message`.
        fn Message::parents(&self) -> Vec<MessageId>;
        /// Returns the optional payload of a `Message`.
        fn Message::payload(&self) -> Option<MessagePayload>;
    }
);

foreign_class!(
    /// A builder to build a `Message`.
    #[derive(camelCaseAliases)]
    class MessageBuilder {
        self_type MessageBuilder;
        /// Creates a new `MessageBuilder`.
        constructor MessageBuilder::new() -> MessageBuilder;
        /// Adds a network id to a `MessageBuilder`.
        fn MessageBuilder::network_id(&self, network_id: u64) -> MessageBuilder;
        /// Adds parents to a `MessageBuilder`.
        fn MessageBuilder::parents(&self, parents: Vec<MessageId>) -> Result<MessageBuilder>;
        /// Adds a payload to a `MessageBuilder`.
        fn MessageBuilder::payload(&self, payload: MessagePayload) -> MessageBuilder;
        //fn MessageBuilder::nonce_provider(&self) -> MessageBuilder;
        fn MessageBuilder::finish(&self) -> Result<Message>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class ClientMessageBuilder {
        self_type ClientMessageBuilder<'a>;
        private constructor = empty;
        /// Sets the seed.
        fn ClientMessageBuilder::with_seed(&self, seed: &str) -> Result<ClientMessageBuilder>;

        /// Sets the account index.
        fn ClientMessageBuilder::with_account_index(&self, account_index: usize) -> ClientMessageBuilder;

        /// Sets the index of the address to start looking for balance.
        fn ClientMessageBuilder::with_initial_address_index(&self, initial_address_index: usize) -> ClientMessageBuilder;

        /// Set a custom input(transaction output)
        fn ClientMessageBuilder::with_input(&self, input: UtxoInput) -> ClientMessageBuilder;

        /// Set a custom range in which to search for addresses for custom inputs. Default: 0..100
        fn ClientMessageBuilder::with_input_range(&self, low: usize, high: usize) -> ClientMessageBuilder;

        /// Set a transfer to the builder
        fn ClientMessageBuilder::with_output(&self, address: &str, amount: u64) -> Result<ClientMessageBuilder>;

        /// Set a dust allowance transfer to the builder, address needs to be Bech32 encoded
        fn ClientMessageBuilder::with_dust_allowance_output(&self, address: &str, amount: u64)  -> Result<ClientMessageBuilder>;

        /// Set a transfer to the builder, address needs to be hex encoded
        fn ClientMessageBuilder::with_output_hex(&self, address: &str, amount: u64)  -> Result<ClientMessageBuilder>;

        /// Set indexation to the builder
        fn ClientMessageBuilder::with_tag_vec(&self, index: Vec<u8>)  -> ClientMessageBuilder;
        /// Set indexation to the builder
        fn ClientMessageBuilder::with_tag_string(&self, index: &str)  -> ClientMessageBuilder;

        /// Set data to the builder
        fn ClientMessageBuilder::with_data(&self, data: Vec<u8>)  -> ClientMessageBuilder;
        /// Set data to the builder
        fn ClientMessageBuilder::with_data_string(&self, data: &str)  -> ClientMessageBuilder;

        /// Prepare a transaction
        fn ClientMessageBuilder::prepare_transaction(&self)  -> Result<PreparedTransactionData>;

        /// Sign the transaction. inputsRangeLow and high to 0 for not using an input range
        fn ClientMessageBuilder::sign_transaction(&self, prepared_transaction_data: PreparedTransactionData,
            seed: &str, inputs_range_low: usize, inputs_range_high: usize) -> Result<MessagePayload>;

        /// Consume the builder and return the message made with the specific payload
        fn ClientMessageBuilder::finish_message(&self, payload: MessagePayload) -> Result<Message>; alias finish;

        /// Consume the builder and return the message made with the specific payload
        fn ClientMessageBuilder::finish_message_transaction(&self, payload: TransactionPayload) -> Result<Message>; alias finishTransaction;
        /// Consume the builder and return the message made with the specific payload
        fn ClientMessageBuilder::finish_message_milestone(&self, payload: MilestonePayload) -> Result<Message>; alias finishMilestone;
        /// Consume the builder and return the message made with the specific payload
        fn ClientMessageBuilder::finish_message_index(&self, payload: TaggedPayload) -> Result<Message>; alias finishIndex;
        /// Consume the builder and return the message made with the specific payload
        fn ClientMessageBuilder::finish_message_receipt(&self, payload: ReceiptPayload) -> Result<Message>; alias finishReceipt;
        /// Consume the builder and return the message made with the specific payload
        fn ClientMessageBuilder::finish_message_treasury(&self, payload: TreasuryPayload) -> Result<Message>; alias finishTreasury;

        /// Consume the builder and return the message
        fn ClientMessageBuilder::finish(&self) -> Result<Message>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class GetMessageBuilder {
        self_type GetMessageBuilder<'a>;
        private constructor = empty;

        /// GET /api/v2/messages?index={Index} endpoint
        /// Consume the builder and search for messages matching the index
        fn GetMessageBuilder::index_string(&self, index: &str) -> Result<Vec<MessageId>>;

        /// GET /api/v2/messages?index={Index} endpoint
        /// Consume the builder and search for messages matching the index
        fn GetMessageBuilder::index_vec(&self, index: Vec<u8>) -> Result<Vec<MessageId>>;

        /// GET /api/v2/messages/{messageID} endpoint
        /// Consume the builder and find a message by its identifer. This method returns the given message object.
        fn GetMessageBuilder::data(&self, message_id: MessageId) -> Result<Message>;

        /// GET /api/v2/messages/{messageID}/metadata endpoint
        /// Consume the builder and find a message by its identifer. This method returns the given message metadata.
        fn GetMessageBuilder::metadata(&self, message_id: MessageId) -> Result<MessageMetadata>;

        /// GET /api/v2/messages/{MessageId} endpoint
        /// Consume the builder and find a message by its identifer. This method returns the given message raw data.
        fn GetMessageBuilder::raw(&self, message_id: MessageId) -> Result<String>;

        /// GET /api/v2/messages/{messageID}/children endpoint
        /// Consume the builder and returns the list of message IDs that reference a message by its identifier.
        fn GetMessageBuilder::children(&self, message_id: MessageId) -> Result<Vec<MessageId>>;
    }
);

foreign_class!(
    /// Response of GET /api/v2/messages/{message_id}/metadata.
    /// Returns the metadata of a message.
    #[derive(camelCaseAliases, Display)]
    class MessageMetadata {
        self_type MessageMetadata;
        private constructor = empty;
        private fn MessageMetadata::to_string(&self) -> String; alias to_string;
        fn MessageMetadata::message_id(&self) -> &str;
        fn MessageMetadata::parent_message_ids(&self) -> Vec<String>;
        fn MessageMetadata::is_solid(&self) -> bool;
        fn MessageMetadata::referenced_by_milestone_index(&self) -> Option<u32>;
        fn MessageMetadata::milestone_index(&self) -> Option<u32>;
        fn MessageMetadata::ledger_inclusion_state(&self) -> Option<LedgerInclusionStateDto>;
        fn MessageMetadata::conflict_reason(&self) -> Option<u8>;
        fn MessageMetadata::should_promote(&self) -> Option<bool>;
        fn MessageMetadata::should_reattach(&self) -> Option<bool>;
    }
);

/////////////// Address

foreign_class!(
    #[derive(Display)]
    class Address {
        self_type Address;
        private constructor = empty;
        private fn Address::to_string(&self) -> String; alias to_string;
        /// Tries to create an `Address` from a Bech32 encoded string.
        fn Address::try_from_bech32(addr: &str) -> Result<Address>;
        // Encodes this address to a Bech32 string with the hrp (human readable part) argument as prefix.
        fn Address::to_bech32(&self, hrp: &str) -> String;
        // Verifies a [`SignatureUnlock`] for a message against the [`Address`].
        fn Address::verify(&self, msg: Vec<u8>, signature: SignatureUnlock) -> Result<()>;
    }
);

foreign_class!(
    #[derive(Display)]
    class AddressStringPublicWrapper {
        self_type AddressStringPublicWrapper;
        private constructor = empty;
        private fn AddressStringPublicWrapper::eq(&self, o: &AddressStringPublicWrapper) -> bool; alias rustEq;
        private fn AddressStringPublicWrapper::to_string(&self) -> String; alias to_string;
        fn AddressStringPublicWrapper::public(&self) -> bool; alias isPublic;
        fn AddressStringPublicWrapper::address(&self) -> &str;
    }
);
foreign_class!(
    #[derive(Display)]
    class AddressPublicWrapper {
        self_type AddressPublicWrapper;
        private constructor = empty;
        private fn AddressPublicWrapper::eq(&self, o: &AddressPublicWrapper) -> bool; alias rustEq;
        private fn AddressPublicWrapper::to_string(&self) -> String; alias to_string;
        fn AddressPublicWrapper::public(&self) -> bool; alias isPublic;
        fn AddressPublicWrapper::address(&self) -> Address;
    }
);

foreign_class!(
    #[derive(Display)]
    class AddressDto {
        self_type AddressDto;
        private constructor = empty;
        private fn AddressDto::to_string(&self) -> String; alias to_string;
        fn AddressDto::kind(&self) -> u8;
        fn AddressDto::address(&self) -> &str;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class GetBalanceBuilderApi {
        self_type GetBalanceBuilderApi<'a>;
        private constructor = empty;

        /// Sets the account index.
        fn GetBalanceBuilderApi::with_account_index(&self, account_index: usize) -> GetBalanceBuilderApi;

        /// Sets the index of the address to start looking for balance.
        fn GetBalanceBuilderApi::with_initial_address_index(&self, initial_address_index: usize) -> GetBalanceBuilderApi;

        /// Sets the gap limit to specify how many addresses will be checked each round.
        /// If gap_limit amount of addresses in a row have no balance the function will return.
        fn GetBalanceBuilderApi::with_gap_limit(&self, gap_limit: usize) -> GetBalanceBuilderApi;

        /// Consume the builder and get the API result
        fn GetBalanceBuilderApi::finish(&self) -> Result<u64>;
    }
);

foreign_class!(
    /// Builder of GET /api/v2/address/{address} endpoint
    class GetAddressBuilder {
        self_type GetAddressBuilder<'a>;
        private constructor = empty;
        /// Consume the builder and get the balance of a given Bech32 encoded address.
        /// If count equals maxResults, then there might be more outputs available but those were skipped for performance
        /// reasons. User should sweep the address to reduce the amount of outputs.
        fn GetAddressBuilder::balance(&self, address: &str) -> Result<BalanceAddressResponse>;
        /// Consume the builder and get all outputs that use a given address.
        /// If count equals maxResults, then there might be more outputs available but those were skipped for performance
        /// reasons. User should sweep the address to reduce the amount of outputs.
        fn GetAddressBuilder::outputs(&self, address: &str, options: OutputsOptions) -> Result<Vec<UtxoInput>>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class GetAddressesBuilder {
        self_type GetAddressesBuilder<'a>;
        private constructor = empty;
        /// Construct a new addressbuilder with a seed. Invalid seeds throw an error
        fn GetAddressesBuilder::from(seed: &str) -> Result<GetAddressesBuilder<'a>>;

        /// DEBUG DO NOT USE
        fn GetAddressesBuilder::from_old(seed: &str) -> GetAddressesBuilder<'a>;

        /// Set the account index
        fn GetAddressesBuilder::with_account_index(&self, account_index: usize) -> GetAddressesBuilder;

        /// Set range to the builder
        fn GetAddressesBuilder::with_range(&self, start: usize, end: usize) -> GetAddressesBuilder;

        /// Set bech32 human readable part (hrp)
        fn GetAddressesBuilder::with_bech32_hrp(&self, bech32_hrp: String) -> GetAddressesBuilder;

        /// Set client to the builder
        fn GetAddressesBuilder::with_client(&self, client: &Client) -> GetAddressesBuilder;

        /// Consume the builder and get a vector of public addresses bech32 encoded
        fn GetAddressesBuilder::finish(&self) -> Result<Vec<String>>;

        // Consume the builder and get the vector of public and internal addresses bech32 encoded
        fn GetAddressesBuilder::get_all(&self) -> Result<Vec<AddressStringPublicWrapper>>;
        /// Consume the builder and get the vector of public and internal addresses
        fn GetAddressesBuilder::get_all_raw(&self) -> Result<Vec<AddressPublicWrapper>>;
    }
);

//////////////// MQTT


foreign_class!(
    #[derive(Display)]
    class Topic {
        self_type Topic;
        private constructor = empty;

        /// Creates a new topic and checks if it's valid.
        fn Topic::from(topic: &str) -> Result<Topic> {
            // Cannot be a constructor due to the Result
            match Topic::new(topic) {
                Ok(t) => Ok(t),
                Err(e) => Err(anyhow!(e.to_string())),
            }
        }

        private fn Topic::to_string(&self) -> String {
            format!("Topic({:?})", this)
        }
    }
);


foreign_class!(
    #[derive(Display)]
    class TopicEvent {
        self_type TopicEvent;
        private constructor = empty;

        private fn TopicEvent::to_string(&self) -> String {
            format!("TopicEvent(topic: {}, payload: {})", this.topic, this.payload)
        }

        /// the MQTT topic.
        fn TopicEvent::topic(&self) -> String {
            this.topic.clone()
        }

        /// The MQTT event payload.
        fn TopicEvent::payload(&self) -> String {
            this.payload.clone()
        }
    }
);

foreign_enum!(
    enum MqttEvent {
        /// Client was connected.
        CONNECTED = MqttEvent::Connected,
        /// Client was disconnected.
        DISCONNECTED = MqttEvent::Disconnected,
    }
);


foreign_class!(
    #[derive(camelCaseAliases)]
    class MqttManager {
        self_type MqttManager<'a>;
        private constructor = empty;

        /// Add a new topic to the list.
        fn MqttManager::with_topic(&mut self, topic: Topic) -> MqttTopicManager;

        /// Add a collection of topics to the list.
        fn MqttManager::with_topics(&mut self, topics: Vec<Topic>) -> MqttTopicManager;

        /// Unsubscribes from all subscriptions.
        fn MqttManager::unsubscribe(&mut self) -> Result<()>;

        /// Disconnects the broker.
        /// This will clear the stored topic handlers and close the MQTT connection.
        fn MqttManager::disconnect(&mut self) -> Result<()>;
    }
);

foreign_callback!(callback MqttListener {
    self_type MqttListener + Send + Sync + 'static;
    onEvent = MqttListener::on_event(&self, event: TopicEvent);
});

foreign_class!(
    #[derive(camelCaseAliases)]
    class MqttTopicManager {
        self_type MqttTopicManager<'a>;
        private constructor = empty;

        /// Add a new topic to the list.
        fn MqttTopicManager::with_topic(&mut self, topic: Topic) -> MqttTopicManager;

        /// Add a collection of topics to the list.
        fn MqttTopicManager::with_topics(&mut self, topics: Vec<Topic>) -> MqttTopicManager;

        /// Unsubscribe from the given topics.
        /// If no topics were provided, the function will unsubscribe from every subscribed topic.
        fn MqttTopicManager::unsubscribe(&mut self) -> Result<()>;

        // Subscribe to the given topics with the callback.
        //fn MqttTopicManager::subscribe(&mut self, cb: Box<dyn MqttListener + Send + 'static>) -> Result<()>;
    }
);

//////////////// Util
///
foreign_class!(
    #[derive(camelCaseAliases)]
    class Util {
        /// Function to consolidate all funds from a range of addresses to the address with the lowest index in that range
        /// Returns the address to which the funds got consolidated, if any were available
        fn crate::consolidate_funds(
            client: Client,
            seed: &str,
            account_index: usize,
            address_range_low: usize,
            address_range_high: usize,
        ) -> Result<String>;

        /// Function to find the index and public or internal type of an Bech32 encoded address
        fn crate::address::search_address(
            seed: &str,
            bech32_hrp: &str,
            account_index: usize,
            range_low: usize,
            range_high: usize,
            address: Address,
        ) -> Result<IndexPublicDto>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class IndexPublicDto {
        self_type IndexPublicDto;
        private constructor = empty;
        fn IndexPublicDto::index(&self) -> usize;
        fn IndexPublicDto::is_public(&self) -> bool;
    }
);

foreign_class!(class RustHex {
    fn hex::encode(_ : String) -> String;
    fn hex::encode(_ : Vec<u8>) -> String;
    fn decode(s : String) -> Result<Vec<u8>> {
        let res = hex::decode(s);
        match res {
            Ok(s) => Ok(s),
            Err(e) => Err(anyhow!("Hex error {:?}", e.to_string()))
        }
    }
    fn decode(s : Vec<u8>) -> Result<Vec<u8>> {
        let res = hex::decode(s);
        match res {
            Ok(s) => Ok(s),
            Err(e) => Err(anyhow!("Hex error {:?}", e.to_string()))
        }
    }
});

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class Signature {
        self_type Signature;
        private constructor = empty;
        private fn Signature::to_string(&self) -> String; alias to_string;
        fn Signature::to_bytes(&self) -> Vec<u8>;
        fn Signature::from_bytes(bs: Vec<u8>) -> Signature;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class PublicKey {
        self_type PublicKey;
        private constructor = empty;
        private fn PublicKey::to_string(&self) -> String; alias to_string;
        fn PublicKey::verify(&self, sig: Signature, msg: Vec<u8>) -> bool;
        fn PublicKey::to_bytes(&self) -> Vec<u8>;
        fn PublicKey::try_from_bytes(bs: Vec<u8>) -> Result<PublicKey>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class SecretKey {
        self_type SecretKey;
        private constructor = empty;
        private fn SecretKey::to_string(&self) -> String; alias to_string;
        fn SecretKey::generate() -> Result<SecretKey>;
        fn SecretKey::from_bytes(bs: Vec<u8>) -> SecretKey;

        fn SecretKey::public_key(&self) -> PublicKey;
        fn SecretKey::to_bytes(&self) -> Vec<u8>;
        fn SecretKey::sign(&self, msg: Vec<u8>) -> Signature;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class Chain {
        self_type Chain;
        private constructor = empty;
    }
);

// Bee types wrapping
foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class MessagePayload {
        self_type MessagePayload;
        private constructor = empty;
        private fn MessagePayload::to_string(&self) -> String; alias to_string;

        /// Turns a serialized message payload string back into its class
        fn MessagePayload::deserialize(serialised_data: &str) -> Result<MessagePayload>;
        /// Get the type of message this contains (used to select the correct getter)
        fn MessagePayload::payload_type(&self) -> MessagePayloadType;
        fn MessagePayload::get_as_indexation(&self) -> Option<TaggedPayload>;
        fn MessagePayload::get_as_transaction(&self) -> Option<TransactionPayload>;
        fn MessagePayload::get_as_treasury(&self) -> Option<TreasuryPayload>;
        fn MessagePayload::get_as_milestone(&self) -> Option<MilestonePayload>;
        fn MessagePayload::get_as_receipt(&self) -> Option<ReceiptPayload>;

        /// Serializes the message payload into a json string
        fn MessagePayload::serialize(&self) -> Result<String>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class TaggedPayload {
        self_type TaggedPayload;
        private constructor = empty;
        private fn TaggedPayload::to_string(&self) -> String; alias to_string;
        /// Creates a new `TaggedPayload`.
        fn TaggedPayload::new(index: &[u8], data: &[u8]) -> Result<TaggedPayload>; alias fromBytes;
        /// Creates a new `TaggedPayload` from strings
        fn TaggedPayload::new_from_string(index: &str, data: &str) -> Result<TaggedPayload>; alias fromStrings;
        /// Returns the index of an `TaggedPayload`.
        fn TaggedPayload::index(&self) -> &[u8];
        /// Returns the data of an `TaggedPayload`.
        fn TaggedPayload::data(&self) -> &[u8];
    }
);

foreign_class!(
    /// A payload which defines the inclusion set of other messages in the Tangle.
    #[derive(camelCaseAliases, Display)]
    class MilestonePayload {
        self_type MilestonePayload;
        private constructor = empty;
        private fn MilestonePayload::to_string(&self) -> String; alias to_string;
        /// Returns the essence of a `MilestonePayload`.
        fn MilestonePayload::essence(&self) -> MilestonePayloadEssence;
        /// Returns the signatures of a `MilestonePayload`.
        fn MilestonePayload::signatures(&self) -> Vec<MilestoneSignature>;
        /// Semantically validate a `MilestonePayload`.
        fn MilestonePayload::validate(&self, applicable_public_keys: Vec<String>, min_threshold: usize) -> Result<()>;
        /// Computes the identifier of a `MilestonePayload`.
        fn MilestonePayload::id(&self) -> String;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class MilestoneSignature {
        self_type MilestoneSignature;
        private constructor = empty;
        private fn MilestoneSignature::to_string(&self) -> String; alias to_string;
        fn MilestoneSignature::get_signature(&self) -> Vec<u8>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class MilestonePayloadEssence {
        self_type MilestonePayloadEssence;
        private constructor = empty;
        private fn MilestonePayloadEssence::to_string(&self) -> String; alias to_string;
        /// Returns the index of a `MilestonePayloadEssence`.
        fn MilestonePayloadEssence::index(&self) -> u32;
        /// Returns the timestamp of a `MilestonePayloadEssence`.
        fn MilestonePayloadEssence::timestamp(&self) -> u64;
        /// Returns the parents of a `MilestonePayloadEssence`.
        fn MilestonePayloadEssence::parents(&self) -> Vec<MessageId>;
        /// Returns the merkle proof of a `MilestonePayloadEssence`.
        fn MilestonePayloadEssence::merkle_proof(&self) -> Vec<u8>;
        /// Returns the next proof of work score of a `MilestonePayloadEssence`.
        fn MilestonePayloadEssence::next_pow_score(&self) -> u32;
        /// Returns the next proof of work index of a `MilestonePayloadEssence`.
        fn MilestonePayloadEssence::next_pow_score_milestone(&self) -> u32;
        /// Returns the public keys of a `MilestonePayloadEssence`.
        fn MilestonePayloadEssence::public_keys(&self) -> Vec<PublicKey>;
        /// Returns the optional receipt of a `MilestonePayloadEssence`.
        fn MilestonePayloadEssence::receipt(&self) -> Option<ReceiptPayload>;
        /// Hashes the `MilestonePayloadEssence to be signed.`
        fn MilestonePayloadEssence::hash(&self) -> Vec<u8>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class ReceiptPayload {
        self_type ReceiptPayload;
        private constructor = empty;
        /// Creates a new `ReceiptPayload`.
        fn ReceiptPayload::from(migrated_at: u32, last: bool, funds: Vec<MigratedFundsEntry>, transaction: MessagePayload) -> Result<ReceiptPayload>;
        private fn ReceiptPayload::to_string(&self) -> String; alias to_string;
        /// Returns the milestone index at which the funds of a `ReceiptPayload` were migrated at in the legacy network.
        fn ReceiptPayload::migrated_at(&self) -> u32;
        /// Returns whether a `ReceiptPayload` is the final one for a given migrated at index.
        fn ReceiptPayload::last(&self) -> bool;
        /// The funds which were migrated with a `ReceiptPayload`.
        fn ReceiptPayload::funds(&self) -> Vec<MigratedFundsEntry>;
        /// The `TreasuryTransaction` used to fund the funds of a `ReceiptPayload`.
        fn ReceiptPayload::transaction(&self) -> TreasuryPayload;
        /// Returns the sum of all `MigratedFundsEntry` items within a `ReceiptPayload`.
        fn ReceiptPayload::amount(&self) -> u64;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class MigratedFundsEntry {
        self_type MigratedFundsEntry;
        private constructor = empty;
        /// Creates a new `MigratedFundsEntry`.
        fn MigratedFundsEntry::from(hash: String, output: SignatureLockedSingleOutput) -> Result<MigratedFundsEntry>;
        private fn MigratedFundsEntry::to_string(&self) -> String; alias to_string;
        /// Returns the tail transaction hash of a `MigratedFundsEntry`.
        fn MigratedFundsEntry::tail_transaction_hash(&self) -> String;
        /// Returns the output of a `MigratedFundsEntry`.
        fn MigratedFundsEntry::output(&self) -> SignatureLockedSingleOutput;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class TransactionPayload {
        self_type TransactionPayload;
        private constructor = empty;
        private fn TransactionPayload::to_string(&self) -> String; alias to_string;
        /// Return a new `TransactionPayloadBuilder` to build a `TransactionPayload`.
        fn TransactionPayload::builder() -> TransactionPayloadBuilder;
        /// Return the essence of a `TransactionPayload`.
        fn TransactionPayload::essence(&self) -> Essence;
        /// Computes the identifier of a `TransactionPayload`.
        fn TransactionPayload::id(&self) -> TransactionId;
        /// Return unlock blocks of a `TransactionPayload`.
        fn TransactionPayload::unlock_blocks(&self) -> Vec<UnlockBlock>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases)]
    class TransactionPayloadBuilder {
        self_type TransactionPayloadBuilder;
        /// Creates a new `TransactionPayloadBuilder`.
        constructor TransactionPayloadBuilder::new() -> TransactionPayloadBuilder;
        /// Adds an essence to a `TransactionPayloadBuilder`.
        fn TransactionPayloadBuilder::with_essence(&self, essence: Essence) -> TransactionPayloadBuilder;
        /// Adds unlock blocks to a `TransactionPayloadBuilder`.
        fn TransactionPayloadBuilder::with_unlock_blocks(&self, unlock_blocks: UnlockBlocks)-> TransactionPayloadBuilder;
        /// Finishes a `TransactionPayloadBuilder` into a `TransactionPayload`.
        fn TransactionPayloadBuilder::finish(&self) -> Result<TransactionPayload>;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    /// Helper struct for offline signing
    class PreparedTransactionData {
        self_type PreparedTransactionData;
        private constructor = empty;
        private fn PreparedTransactionData::to_string(&self) -> String; alias to_string;

        /// Turns a serialized preparedTransactionData string back into its class
        fn PreparedTransactionData::deserialize(serialised_data: &str) -> Result<PreparedTransactionData>;

        /// Transaction essence
        fn PreparedTransactionData::essence(&self) -> Essence;
        /// Required address information for signing
        fn PreparedTransactionData::inputs_data(&self) -> Vec<InputSigningData>;

        /// Serializes the prepared data into a json string
        fn PreparedTransactionData::serialize(&self) -> Result<String>;

    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    /// Structure for sorting of UnlockBlocks
    class InputSigningData {
        self_type InputSigningData;
        private constructor = empty;
        private fn InputSigningData::to_string(&self) -> String; alias to_string;
        /// Index of the account
        fn InputSigningData::account_index(&self) -> usize;
        /// The input used
        fn InputSigningData::input(&self) -> Input;
        /// The output information
        fn InputSigningData::output(&self) -> OutputResponse;
        /// index of this address on the seed
        fn InputSigningData::address_index(&self) -> usize;
        /// The chain derived from seed
        fn InputSigningData::chain(&self) -> Chain;
        /// Whether this is an internal address
        fn InputSigningData::internal(&self) -> bool;
        /// The address
        fn InputSigningData::bech32_address(&self) -> &str;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class Essence {
        self_type Essence;
        private constructor = empty;
        private fn Essence::to_string(&self) -> String; alias to_string;
        fn Essence::get_as_regular(&self) -> Option<RegularEssence>;
    }
);

foreign_class!(
    #[derive(Display)]
    class RegularEssence {
        self_type RegularEssence;
        private constructor = empty;
        private fn RegularEssence::to_string(&self) -> String; alias to_string;
        /// Gets the transaction inputs.
        fn RegularEssence::inputs(&self) -> Vec<Input>;
        /// Gets the transaction outputs.
        fn RegularEssence::outputs(&self) -> Vec<Output>;
        // Gets the transaction chained payload.
        fn RegularEssence::payload(&self) -> Option<MessagePayload>;
    }
);
foreign_class!(
    #[derive(Display)]
    class Input {
        self_type Input;
        private constructor = empty;
        private fn Input::to_string(&self) -> String; alias to_string;
        fn Input::kind(&self) -> InputKind;
    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class Output {
        self_type Output;
        private constructor = empty;
        private fn Output::to_string(&self) -> String; alias to_string;
        fn Output::kind(&self) -> OutputKind;
        fn Output::as_signature_locked_single_output(&self) -> Result<SignatureLockedSingleOutput>;
        fn Output::as_signature_locked_dust_allowance_output(&self) -> Result<SignatureLockedDustAllowanceOutput>;
        fn Output::as_treasury_output(&self) -> Result<TreasuryOutput>;
    }
);

foreign_class!(
    #[derive(Display)]
    class ReferenceUnlock {
        self_type ReferenceUnlock;
        private constructor = empty;
        private fn ReferenceUnlock::to_string(&self) -> String; alias to_string;
        /// Creates a new `ReferenceUnlock`.
        fn ReferenceUnlock::from(index: u16) -> Result<ReferenceUnlock>;
        /// Return the index of a `ReferenceUnlock`.
        fn ReferenceUnlock::index(&self) -> u16;
    }
);

foreign_class!(
    #[derive(Display)]
    class SignatureUnlock {
        self_type SignatureUnlock;
        constructor SignatureUnlock::from(public_key: Vec<u8>, signature: Vec<u8>) -> SignatureUnlock;
        private fn SignatureUnlock::to_string(&self) -> String; alias to_string;

    }
);

foreign_class!(
    #[derive(camelCaseAliases, Display)]
    class UnlockBlock {
        self_type UnlockBlock;
        private constructor = empty;
        private fn UnlockBlock::to_string(&self) -> String; alias to_string;
        fn UnlockBlock::kind(&self) -> UnlockBlockKind;

        fn UnlockBlock::get_as_reference(&self) -> Option<ReferenceUnlock>;
        fn UnlockBlock::get_as_signature(&self) -> Option<SignatureUnlock>;
    }
);

foreign_class!(
    #[derive(Display)]
    class UnlockBlocks {
        self_type UnlockBlocks;
        private constructor = empty;
        private fn UnlockBlocks::to_string(&self) -> String; alias to_string;
        fn UnlockBlocks::from(unlock_blocks: Vec<UnlockBlock>) -> Result<UnlockBlocks>;
        /// Gets a clone of an `UnlockBlock` from `UnlockBlocks`.
        /// Returns the referenced unlock block if the requested unlock block was a reference.
        fn UnlockBlocks::get(&self, index: usize) -> Option<UnlockBlock>;
    }
);

foreign_class!(
    #[derive(Display)]
    class TreasuryPayload {
        self_type TreasuryPayload;
        constructor TreasuryPayload::new(input: TreasuryInput, output: TreasuryOutput) -> TreasuryPayload;
        private fn TreasuryPayload::to_string(&self) -> String; alias to_string;
        fn TreasuryPayload::output(&self) -> TreasuryOutput;
        fn TreasuryPayload::input(&self) -> TreasuryInput;
    }
);
