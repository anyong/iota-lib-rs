---
title: Get Node Information
description: You can access all the features of the iota.rs library using an instance of the Client class. The Client class provides high-level abstraction to all interactions over IOTA network (Tangle).
image: /img/logo/iota_mark_light.png
keywords:
- how to
- client class
- iota node
- ClientBuilder
- load balancer
- wasm
---
import CodeBlock from '@theme/CodeBlock';
import get_info from '!!raw-loader!./../../../../../bindings/wasm/examples/01_get_info.js';
import b_get_info from '!!raw-loader!./../../../../../bindings/wasm/examples/01b_get_info.js';

# Get Node Info

:::warning
It is not recommended to store passwords/seeds on host's environment variables or in the source code in a production
setup. Please make sure you follow our [backup and security](https://wiki.iota.org/chrysalis-docs/guides/backup_security)
recommendations for production use.
:::

## Connecting to Node(s)

You can access all the features of the `iota.rs` library using an instance of the `Client` class. The `Client` class
provides high-level abstraction to all interactions over IOTA network (Tangle). You have to instantiate this class
before you start any interactions with the library, or more precisely with the
[IOTA nodes](https://wiki.iota.org/chrysalis-docs/node_software) that power IOTA network.

In the `nodejs` binding, you can instantiate the `Client` instance, and optionally configure it, by chaining calls to the
`ClientBuilder` helper class.

The library is designed to automatically choose a starting IOTA node based on the network type you would like to
participate in: [`devnet`](https://wiki.iota.org/chrysalis-docs/devnet) or
[`mainnet`](https://wiki.iota.org/chrysalis-docs/mainnet).

You can use the following example to connect to [IOTA devnet](https://wiki.iota.org/chrysalis-docs/devnet):

<CodeBlock className="language-javascript">
    {get_info}
</CodeBlock>

**Output example** of the `getInfo()` function of the `ClientBuilder` instance:

```json
{
   "nodeinfo":{
      "name":"HORNET",
      "version":"0.6.0-alpha",
      "isHealthy":true,
      "networkId":"migration",
      "bech32HRP":"atoi",
      "minPoWScore":100,
      "messagesPerSecond":4.2,
      "referencedMessagesPerSecond":4.1,
      "referencedRate":97.61904761904762,
      "latestMilestoneTimestamp":1618139001,
      "latestMilestoneIndex":7092,
      "confirmedMilestoneIndex":7092,
      "pruningIndex":0,
      "features":[
         "PoW"
      ]
   },
   "url":"https://api.lb-0.h.chrysalis-devnet.iota.cafe"
}
```

The most important properties are:
* `isHealthy`: Indicates whether the given node is in sync with the network and therefore safe to use. Even if a node is
up and running, it may not be fully prepared to process your API calls properly. The node should be "synced", meaning
that it should be aware of all transactions in the Tangle. It is better to avoid interacting with nodes which are not
fully synced.
* `bech32HRP`: Indicates whether the given node is a part of [devnet](https://wiki.iota.org/chrysalis-docs/devnet)
(`atoi`) or [mainnet](https://wiki.iota.org/chrysalis-docs/mainnet) (`iota`). You can find more info regarding the
[IOTA address format](https://wiki.iota.org/chrysalis-docs/guides/developer/#iota-15-address-anatom) in the official
[Chrysalis documentation](https://wiki.iota.org/chrysalis-docs/welcome).

:::note

If you use node load balancers then the health check may be useless as the follow-up API calls may be served by a
different node behind the load balancer that may have not been checked. You should be aware of this fact and trust the
load balancer participates only with nodes that are in healthy state. The `iota.rs` library additionally supports
a management of internal node pool, so you can mimic a load-balancer-like behavior using this feature locally.

:::

The `ClientBuilder` helper class provides several chaining calls through which the process
can be closely managed.

The most common ones are:

* `.network(str)`: Can be either `devnet` or `mainnet`. It instructs
the library whether to automatically select devnet nodes or mainnet nodes.
* `.node(url)`: Specify address of actual running IOTA node that should be used
to communicate with in the format `https://node:port`). For example: `https://api.lb-0.h.chrysalis-devnet.iota.cafe:443`.
* `.nodePoolUrls(urls)`: The library also supports managing a pool of
nodes. You can provide a list of nodes and the library manages the access to them automatically by selecting them based
on their sync status. If you provide `.nodePoolUrls(urls)`, then the library periodically will periodically check whether node is in sync or
not by calling `.nodeSyncInterval(interval)`.
* `.localPow(bool)`: If `.localPow (True)` a Proof-of-work will be done
locally and not remotely.
* `.disableNodeSync()`: When called, the library will use nodes that
are **not** in sync with network. This parameter is usually useful if you would like to interact with a local test node
that is not fully synced. **This parameter should not be used in production**.

The following example uses additional initialization chaining calls, such as leveraging a custom node:

<CodeBlock className="language-javascript">
    {b_get_info}
</CodeBlock>