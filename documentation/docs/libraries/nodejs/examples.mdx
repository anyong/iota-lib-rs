---
title: Examples
description: Official IOTA Client Library Software Node.js examples.
image: /img/logo/iota_mark_light.png
keywords:
- account
- address
- nodejs
- message
- output
---
import CodeBlock from '@theme/CodeBlock';
import get_info from '!!raw-loader!./../../../../bindings/nodejs/examples/01_get_info.js';
import b_get_info from '!!raw-loader!./../../../../bindings/nodejs/examples/01b_get_info.js';
import generate_seed from '!!raw-loader!./../../../../bindings/nodejs/examples/02_generate_seed.js';
import generate_addresses from '!!raw-loader!./../../../../bindings/nodejs/examples/03_generate_addresses.js';
import get_balance from '!!raw-loader!./../../../../bindings/nodejs/examples/04_get_balance.js';
import a_get_address_outputs from '!!raw-loader!./../../../../bindings/nodejs/examples/05a_get_address_outputs.js';
import b_get_output from '!!raw-loader!./../../../../bindings/nodejs/examples/05b_get_output.js';
import c_find_outputs from '!!raw-loader!./../../../../bindings/nodejs/examples/05c_find_outputs.js';
import simple_message from '!!raw-loader!./../../../../bindings/nodejs/examples/06_simple_message.js';
import get_message_data from '!!raw-loader!./../../../../bindings/nodejs/examples/07_get_message_data.js';
import data_message from '!!raw-loader!./../../../../bindings/nodejs/examples/08_data_message.js';
import transaction from '!!raw-loader!./../../../../bindings/nodejs/examples/09_transaction.js';
import mqtt from '!!raw-loader!./../../../../bindings/nodejs/examples/10_mqtt.js';

:::warning
It is not recommended to store passwords/seeds on host's environment variables or in the source code in a production
setup. Please make sure you follow our [backup and security](https://wiki.iota.org/chrysalis-docs/guides/backup_security)
recommendations for production use.
:::

## Connecting to Node(s)

You can access all the features of the `iota.rs` library using an instance of the [`Client`](api_reference#client) class. The [`Client`](api_reference#client) class
provides high-level abstraction to all interactions over IOTA network (Tangle). You have to instantiate this class
before you start any interactions with the library, or more precisely with the
[IOTA nodes](https://wiki.iota.org/chrysalis-docs/node_software) that power IOTA network.

In the `nodejs` binding, you can instantiate the [`Client`](api_reference#client) instance, and optionally configure it, by chaining calls to the
 [`ClientBuilder`](api_reference#clientbuilder) helper class.

The library is designed to automatically choose a starting IOTA node based on the network type you would like to
participate in: [`devnet`](https://wiki.iota.org/chrysalis-docs/devnet) or
[`mainnet`](https://wiki.iota.org/chrysalis-docs/mainnet).

You can use the following example to connect to [IOTA devnet](https://wiki.iota.org/chrysalis-docs/devnet):

<CodeBlock className="language-javascript">
  {get_info}
</CodeBlock>

**Output example** of the [`getInfo()`](api_reference#getinfo-promise) function of the [`ClientBuilder`](api_reference#clientbuilder) instance:

```json
{
   "nodeinfo":{
      "name":"HORNET",
      "version":"0.6.0-alpha",
      "isHealthy":true,
      "networkId":"migration",
      "bech32HRP":"atoi",
      "minPoWScore":100,
      "messagesPerSecond":4.2,
      "referencedMessagesPerSecond":4.1,
      "referencedRate":97.61904761904762,
      "latestMilestoneTimestamp":1618139001,
      "latestMilestoneIndex":7092,
      "confirmedMilestoneIndex":7092,
      "pruningIndex":0,
      "features":[
         "PoW"
      ]
   },
   "url":"https://api.lb-0.h.chrysalis-devnet.iota.cafe"
}
```

The most important properties are:
* `isHealthy`: Indicates whether the given node is in sync with the network and therefore safe to use. Even if a node is
up and running, it may not be fully prepared to process your API calls properly. The node should be "synced", meaning
that it should be aware of all transactions in the Tangle. It is better to avoid interacting with nodes which are not
fully synced.
* `bech32HRP`: Indicates whether the given node is a part of [devnet](https://wiki.iota.org/chrysalis-docs/devnet)
(`atoi`) or [mainnet](https://wiki.iota.org/chrysalis-docs/mainnet) (`iota`). You can find more info regarding the
[IOTA address format](https://wiki.iota.org/chrysalis-docs/guides/developer/#iota-15-address-anatom) in the official
[Chrysalis documentation](https://wiki.iota.org/chrysalis-docs/welcome).

:::note

If you use node load balancers then the health check may be useless as the follow-up API calls may be served by a
different node behind the load balancer that may have not been checked. You should be aware of this fact and trust the
load balancer participates only with nodes that are in healthy state. The `iota.rs` library additionally supports
a management of internal node pool, so you can mimic a load-balancer-like behavior using this feature locally.

:::

The [`ClientBuilder`](api_reference#clientbuilder) helper class provides several chaining calls through which the process
can be closely managed.

The most common ones are:

* [`.network(str)`](api_reference#networknetworkname-clientbuilder): Can be either `devnet` or `mainnet`. It instructs
the library whether to automatically select devnet nodes or mainnet nodes.
* [`.node(url)`](api_reference#nodesurls-clientbuilder): Specify address of actual running IOTA node that should be used
to communicate with in the format `https://node:port`). For example: `https://api.lb-0.h.chrysalis-devnet.iota.cafe:443`.
* [`.nodePoolUrls(urls)`](api_reference#nodepoolurlsurls-clientbuilder): The library also supports managing a pool of
nodes. You can provide a list of nodes and the library manages the access to them automatically by selecting them based
on their sync status. If you provide `.nodePoolUrls(urls)`, then the library periodically will periodically check whether node is in sync or
not by calling `.nodeSyncInterval(interval)`.
* [`.localPow(bool)`](api_reference#localpowlocal-clientbuilder): If `.localPow (True)` a Proof-of-work will be done
locally and not remotely.
* [`.disableNodeSync()`](api_reference#disablenodesync-clientbuilder): When called, the library will use nodes that
are **not** in sync with network. This parameter is usually useful if you would like to interact with a local test node
that is not fully synced. **This parameter should not be used in production**.

The following example uses additional initialization chaining calls, such as leveraging a custom node:

<CodeBlock className="language-javascript">
  {b_get_info}
</CodeBlock>

## Generating a Seed and Addresses

Since the IOTA network is permission-less, anybody is able to use it and interact with it. No central authority is
required at any stage. So anybody is able to generate their own `seed` and then deterministically generate the
respective private keys/addresses.

:::info

Please note, it is highly recommended that you avoid using online seed generators. The seed is the only key to the given
addresses. So, anyone who owns the seed also owns all the funds related to respective IOTA addresses.

:::

:::warning
Though it is possible to send transactions with iota.rs, we strongly recommend that you use official
[`wallet.rs`](https://wiki.iota.org/wallet.rs/welcome) library together with the
[`stronghold.rs`](https://wiki.iota.org/stronghold.rs/welcome) enclave for value-based transfers. This combination
incorporates the best security practices while dealing with seeds, related addresses and `UTXO`.
:::

IOTA uses the `Ed25519` signature scheme and addresses are usually represented by Bech32 (checksummed base32) format
string of 64 characters.

A root of the `Ed25519` signature scheme is basically a `32-byte (256-bit)` uniformly randomly generated seed
on which all private keys and corresponding addresses are generated. In the examples below, the seed is represented by
a string of 64 characters using the `[0-9a-f]` alphabet (32 bytes encoded in hexadecimal).

A seed can be generated, for example, using the SHA256 algorithm on some random input generated by a cryptographically
secure pseudo-random generator, such as `crypto.randomBytes()`:

<CodeBlock className="language-javascript">
  {generate_seed}
</CodeBlock>

**Output example**:
```plaintext
39bccf7b88a8017e6a96e6f31e34f138829c574dc6061523e84c5f2e53f5ca36
pass phrase weapon yellow diary scissors gift drive strategy antique scheme make surround aerobic mystery coral hope lock walnut become exclude only glove syrup
eff5c97c96ddab55d6fe78f914508750152eaab1b9692236bc79268895ecfd168e91eedd2489ed6c51fc44156b9a2e6c967e4edcfb649ff33d41581be4627347
```

:::info
In modern wallet implementations such as the [wallet.rs library](https://wiki.iota.org/wallet.rs/welcome) and the
[firefly wallet](https://blog.iota.org/firefly-beta-release/), the seed is usually generated from a `seed mnemonic`
(`seed phrase`), using [BIP39 standard](https://en.bitcoin.it/wiki/BIP_0039), to be better memorized/stored by humans.
It is based on a randomly generated list of english words and later used to generate the seed. The seed is a root for
all generated private keys and addresses.
:::

### Address/Key Space

Before getting the actual address generation process, you should familiarize yourself with the
[BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) standard that describes an approach to
_Hierarchical Deterministic Wallets_. The standard was improved by [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) lately.

This standard defines a tree structure as a base for address and key space generation which is represented by a
`derivation path`:

```plaintext
m / purpose / coin_type / account / change / address_index
```

* `m`: A master node (seed).
* `purpose`: A constant which is {44}.
* `coin_type`: A constant set for each crypto currency. IOTA = 4218, for instance.
* `account`: Account index. Zero-based increasing `int`. This level splits the address/key space into independent branches (ex. user identities) which each has own set of addresses/keys.
* `change`: Change index which is `{0, 1}`, also known as `wallet chain`.

    There are two independent chains of addresses/keys. `0` is reserved for public addresses (to receive coins) and `1` is reserved for internal addresses(also known as change) to which transaction change is returned. IOTA is allows address reuse, and so it is, technically speaking, valid to return transaction change to the same originating address. It is up to developers whether to leverage it or not. The `iota.rs` library and its sibling `wallet.rs` help with either scenario.
* `address_index`: Address index. Zero-based increasing `int` that indicates an address index.

As outlined, there is quite a large address/key space that is secured by a single unique seed.

And there are few additional interesting notes:

* Each level defines a completely different subtree (subspace) of addresses/keys, and those are never mixed up.
* The hierarchy is ready to "absorb" addresses/keys for many coins at the same time (`coin_type`), and all those coins
are secured by the same seed.This means any BIP32/44-compliant wallet is potentially able to manage any \
BIP32/44-compliant coin(s).
* There may be also other `purposes` in the future. However, consider a single purpose for now. The constant `44` stands
for BIP44.
* The standard was agreed upon by different crypto communities, although not all `derivation path` components are always \
in active use. For example, `account` is not always actively leveraged across the crypto space (if this is the case then
`account=0` is usually used).
* Using different `accounts` may be useful to split addresses/keys into some independent spaces, and it is up to
developers to implement.<br />

:::note

Using different `accounts` may have a negative impact on a performance while you are on the
[account discovery](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#account-discovery) phase. If you
are planning on using many multiple accounts then you may be interested in our stateful library
[wallet.rs](https://wiki.iota.org/wallet.rs/welcome) that incorporates all business logic needed to efficiently manage
independent accounts. Our [exchange guide](https://wiki.iota.org/docs/build/exchange-integration/exchange-integration-guide)
provides some useful tips on how different accounts may be leveraged.

:::

![address_generation](/img/libraries/address_generation.svg)

In case of IOTA, the derivation path of address/key space is `[seed]/44/4218/{int}/{0,1}/{int}`. The levels `purpose`
and `coin_type` are given, the rest levels are up to developers to integrate.

### Generating Address(es)

You can generate an IOTA address using the `AddressGetter` helper class and calling the `Client.getAddresses()` function
and respective chaining calls that will return a list of tuples with generated addresses. You can find more information \
on the parameters in the [Address/Key Space section](#addresskey-space).

:::note
For the examples outlined below, an example seed `b3d7092195c36d47133ff786d4b0a1ef2ee6a0052f6e87b6dc337935c70c531e` was
used via environment variable called `IOTA_SEED_SECRET`. This seed serves for training purposes only.
:::

The whole process is deterministic. This means the output is the same as long as the seed is the same:

<CodeBlock className="language-javascript">
  {generate_addresses}
</CodeBlock>

**Output example**:

```string
[
  'atoi1qz6dr6dtl0856tf0pczz7gesrf7j8a4vr00q58ld2zx7ttlv3p96snpym9z',
  'atoi1qpp7sz28a0ghvd6knwnljr7j2s04qquduuc5vlz94fwf94zznj2yv5ew2c4',
  'atoi1qzje6zhg5vu456eg3z84ekcfn3laxqyczche5eeqhcdh3w9yr5sqvr4z4td',
  'atoi1qqwhxjmcvmatpedeedapgx0vwyupfwx9k5n4w0lnc5l6vmz78aavwhs55v0',
  'atoi1qzg63t9880jtfysvpq7rrynz0rqt3kd2fw8r4934ezraz9dpwvzxkw2dtmh'
]
```

IOTA addresses are represented by a checksumed base-32 string (Bech32). You can find a detailed explanation in the
[Chrysalis documentations](https://wiki.iota.org/chrysalis-docs/guides/developer/#iota-15-address-anatom), but here are
parts relevant to this example:

* If an address starts with `atoi` then it means it is related to `devnet`. `iota` stands for `mainnet`.
* Number `1` at 5<sup>th</sup> position is just a separator.
* The last 6 characters are reserved for a checksum.

Addresses can be also represented in a hex format and `iota.rs` provides some convenient functions to convert addresses:
[`Client.bech32ToHex(bech32)`](api_reference#bech32tohexbech32) and
[`Client.hexToBech32(hex, bech32_hrp (optional))`](#hextobech32hex-bech32_hrp-optional).

If you want to quickly validate any IOTA address, you can use the function
[`Client.isAddressValid()`](api_reference#isaddressvalidaddress-string-boolean) that returns a `bool` value. You should
perform a sanity check of an address before using it.

## Checking a Balance

:::note

You can use the [faucet service](https://faucet.chrysalis-devnet.iota.cafe/)  to send test tokens to any Chrysalis
[devnet](https://wiki.iota.org/chrysalis-docs/devnet) address.

:::

There are three common API calls you can use to get a balance:

* `Client.getAddressBalance(str)`: It expects a single address in Bech32 format and returns `dict` with a balance for the address.
* `Client.getAddressBalances([])`: A convenient function that expects `list` of addresses in Bech32 format and returns list of `dict` with balances for all given addresses
* `Client.getBalance(seed)`: A convenient helper `BalanceGetter` class that combines `Client.getAddresses()` and `Client.getAddressBalance()` api calls. It returns a combined balance for the provided `seed` and optional chaining calls `.accountIndex(index)`, `.initialAddressIndex(index)` and `.gapLimit(amount)`

<CodeBlock className="language-javascript">
  {get_balance}
</CodeBlock>

Example of output:

```json
{
   "address":"atoi1qp9427varyc05py79ajku89xarfgkj74tpel5egr9y7xu3wpfc4lkpx0l86",
   "balance":10000000,
   "dustAllowed":false
}
Account balance: 0
```

* `dustAllowed` indicates whether the given address is allowed to accept a dust due to
[dust protection mechanism](https://wiki.iota.org/chrysalis-docs/faq#what-is-dust-protection-and-how-does-it-work).

`Client.getBalance(seed)` performs several tasks under the hood. It starts by generating addresses for the provided
`seed` and `.accountIndex` from `.initialAddressIndex(index)`, and checks for a balance of each of the generated
addresses. Since it does not know how many addresses are used in fact, there is a condition set by the
`.gapLimit(amount)` argument to know when to stop searching. If the `.gapLimit` amount of addresses in a row have no
balance, the function returns results and searching does not continue.

## Messages, Payloads and Transactions

There are additional terms that describe a unit that is actually broadcast in the IOTA network.
IOTA is based on a concept of `messages` and `payloads`.

### Messages

A `message` is a data structure that is actually being broadcast in the IOTA network and represents a node (vertex) in
the Tangle graph. It can refer to up to 8 previous messages and once a message is attached to the Tangle and approved by
a milestone, the Tangle structure ensures the content of the message is unaltered. Every message is referenced by
`message_id` which is based on a hash algorithm of binary content of the message. A `message` is an atomic unit that is
confirmed by the network as a whole.

:::info

IOTA is no longer based on ternary. IOTA 1.5 (Chrysalis) uses binary to encode and broadcast all underlying data entities

:::

A `message` is broadcast using a binary format, its size is arbitrary (up to 32 kB), and it can hold variable sets of
information called `payloads`. The number of payloads a single message can encapsulate is not given and even a message
without any `payload` at all is completely valid.

### Payloads
A `payload` represents a layer of concern. Some payloads may change a state of the ledger(for example, `transactions`)
and some may provide extra features to some specific applications and business use cases (for example, `indexed data`).

You can find there are [core payloads](#core-payloads) which are already implemented, such as `SignedTransaction`, `MilestonePayload` and
`IndexationPayload`. However, the message and payload definition is generic enough to incorporate any future payload(s)
the community agrees upon.

The IOTA network ensures the outer structure of a message itself is valid and aligned with a network consensus protocol.
However, the inner structure is very flexible, future-proof, and offers unmatched network extensibility.

![messages_in_tangle](/img/libraries/messages_in_tangle.svg)

#### Core Payloads

The current IOTA network incorporates the following core payloads:

* `SignedTransaction`: payload that describes `UTXO` transactions that are the cornerstone of value-based transfers in the IOTA network. Via this payload, `message` can be also cryptographically signed
* `MilestonePayload`: payload that is emitted by Coordinator
* `IndexationPayload`: payload that enables addition of an index to the encapsulating message, as well as some arbitrary data. The given index can be later used to search the message(s)

### Unspent Transaction Output (UTXO)

IOTA uses the `unspent transaction output` model called `UTXO`. It is based on the idea to track unspent amount of
tokens via a data structure called `output`.

Consider the following simplified analogy:
1. There are 100 tokens recorded in the ledger as Output A and this output belongs to Alice. So, the initial state of
ledger is Output A = 100 tokens.
2. Alice sends 20 tokens to Paul, 30 tokens to Linda and keeps 50 tokens at her disposal.
3. Her 100 tokens are recorded as Output A. So, she has to divide the spent tokens and create three new outputs:
    * Output B with 20 tokens that goes to Paul.
    * Output C with 30 tokens that goes to Linda.
    * Output D with the remaining 50 tokens that she keep for herself.
4. The original Output A was completely spent and can not be used anymore. It has been spent and so it becomes
irrelevant to the ledger state.
5. The new state of ledger is:
    * Output B with Paul's 20 tokens.
    * Output C with Linda's 30 tokens.
    * Output D with Alice's remaining 50 tokens.

As you can see, the total supply remains the same. It is just the number of outputs that differ, and that some outputs
were replaced by other outputs in the process

![utxo](/img/libraries/utxo.svg)

The key takeaway is the fact that **each `output` can only be spent once**. Once the given `output` is spent, it ca not
be used any more and is irrelevant to the ledger state.

So even if Alice still wants to keep the remaining tokens at her fingertips, those tokens have to be moved to completely
new `output`. This new `output` can still be tied to Alice's same iota address as before.

Every `output` also stores information about an IOTA address to it is coupled with. This means addresses and tokens are
indirectly coupled via `outputs`. The sum of outputs and their amounts under a given address is a balance of said
address. In other words, the number of tokens the given address can spend. The sum of all unspent outputs and their
amounts equals to the total supply.

`Outputs` are sent and broacast to the network encapsulates in a [`message`](#messages) as part of the
`SignedTransaction` [payload](#payloads).

## Outputs

There are three functions to get `UTXO` outputs related an address:

* `Client.getAddressOutputs(str)`:
* `Client.getOutput(str)`: Expects an `output_id` and returns the UTXO output metadata associated with it.
* `Client.findOutputs(output_ids (optional), addresses (optional))`: Searches for `UTXO` outputs associated with the
 `output_ids` and/or `addresses`.

#### Client.getAddressOutputs(str)

This [`Client.getAddressOutputs(str)`](api_reference#getaddressoutputsaddress-options-promisestring) expects an address in
Bech32 format and returns a `str[]` of `output_ids`.

<CodeBlock className="language-javascript">
  {a_get_address_outputs}
</CodeBlock>

**Output example**:

```json
[
  '0f2d5d2651f8061a9f5417d0658009f32b2e3f77f9706b0be3b4b3f466171f360000',
  '7614ba900a90b130707766a660a454942ac7cc4adea3fb9ad0cdca90114417c20000',
  '768c20c15a290e02a43b83263a98501b9d7eb0b57da40a9247289c672de63ea60000'
]
```

#### Client.getOutput(str)

The function [`Client.getOutput(str)`](api_reference#getoutputoutputid-promise) can be used to get metadata about the
given `output_id`:

<CodeBlock className="language-javascript">
  {b_get_output}
</CodeBlock>

**Output example**:

```json
{
  "messageId": "f303bc90a5ed3ef15af5fc6aa81a739978c59458a71e68ce8e380f1f534da1e6",
  "transactionId": "0f2d5d2651f8061a9f5417d0658009f32b2e3f77f9706b0be3b4b3f466171f36",
  "outputIndex": 0,
  "isSpent": false,
  "address": "atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r",
  "amount": 1000000
}
```

#### Client.findOutputs(output_ids (optional), addresses (optional))

The function [`Client.findOutputs()`](api_reference#findoutputsoutputids-addresses-promiseoutputmetadata) is a convenient
shortcut combining both [`Client.getAddressOutputs(str)`](api_reference#getaddressoutputsaddress-options-promisestring)
and [`Client.getOutput(str)`](api_reference#getoutputoutputid-promise) methods in a single call. It supports two
arguments, a list of `output_ids` or a list of [`addresses`](api_reference#address).

<CodeBlock className="language-javascript">
  {c_find_outputs}
</CodeBlock>

**Output example**:

```json
[
  {
    "messageId": "f303bc90a5ed3ef15af5fc6aa81a739978c59458a71e68ce8e380f1f534da1e6",
    "transactionId": "0f2d5d2651f8061a9f5417d0658009f32b2e3f77f9706b0be3b4b3f466171f36",
    "outputIndex": 0,
    "isSpent": false,
    "address": "atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r",
    "amount": 1000000
  },
  {
    "messageId": "825266a79c0ffb6001ed263eb150357863b7d0052627c5766e8ef5acd6fed533",
    "transactionId": "768c20c15a290e02a43b83263a98501b9d7eb0b57da40a9247289c672de63ea6",
    "outputIndex": 0,
    "isSpent": false,
    "address": "atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r",
    "amount": 1000000
  }
]
```

* `message_id`: Refers to the encapsulating message in which the transaction was sent.
* `transaction_id`, `output_index`: Refers to the output within the `SignedTransaction` payload. There may be several
`outputs` involved in a single transaction, so the `transaction_id` by itself would not be enough.
* `output`: This section provides details about the iota address to which the given
[unspent transaction output](#unspent-transaction-output-utxo) is
coupled with.
* `amount`: States an amount of tokens related to the `output`.
* `is_spent`: Indicates whether the given `output` is a part of the actual ledger state or not. As mentioned in the
[Unspent Transaction Output section](#unspent-transaction-output-utxo), if an output was already spent it is not part
of the ledger state any more and is replaced by some other `output(s)` in the process.

Notice that the `output_id` that was used in a function call to get output details is the same as a combination of the
`transaction_id` and `output index`. This way a transaction is tightly coupled with `outputs` since the
`SignedTransaction` payload is a main vehicle to create and spend `outputs`, and everything is encapsulated in a
[`message`](api_reference#message).

## Messages

A `message` is an encapsulating data structure that is being actually broadcast across the network. It is an atomic unit
that is either accepted or rejected as a whole.

The function [`Client.postMessage(message)`](api_reference#postmessagemessage-promise) accepts a message instance as a
parameter and sends it over a network. Alternatively, there is a convenient
[MessageSender](api_reference#messagesender) helper class with chaining calls that prepares a message instance and
broadcasts it over the network.

The simplest message that can be broadcast is a message without any particular payload as shown in the following example.

<CodeBlock className="language-javascript">
  {simple_message}
</CodeBlock>

**Output example**:

```string
{
  message: {
    networkId: '14379272398717627559',
    parentMessageIds: [
      '03ddc83fad172a322fb00fb4e449436e9d1117ff390879100647c650a30c2d52',
      '252798210fa9816f6fd40f1b19095da9f2dc88ae06fc4c0523a928a29d0d782e',
      'a8e4f4cd49227068424ead8da187a48fdaa7ce8ffc4b9ac0ee2d5d3f2fcd7e70',
      'dbbc8044bc624b3378e1dda83ab95f9be468b06a6a9806c76a70353182028cf9'
    ],
    payload: null,
    nonce: '9223372036854784215'
  },
  messageId: '10dbee9cf3c58507725861b34ac711058dc13f709be1a6d21f1dc0af17b06379'
}
```

* `message_id` is a unique id that refers to the given message in the network.

Once a message is broadcast, you can use the [MessageFinder](api_reference#messagefinder) helper class which can be
instantiated using the [`Client.getMessage()`](api_reference#getmessageidmessage-string-boolean) function. The
MessageFinder provides helper functions related to the message, such as
[`Client.getMessage().data(str)`](api_reference#dataid-promise) and
[`Client.getMessage().metadata(str)`](api_reference#metadataid-promise):

<CodeBlock className="language-javascript">
  {get_message_data}
</CodeBlock>

**Output example**:

```json
Message meta data:
{
   "messageId":"e52b631bc7500366b90c6e11eb7fd6abaa7527f9bb5b4b512b0b9112bb9e7be8",
   "parentMessageIds": [
      "26d72339ed262c1ec29d6c91de6be26d067b3327191f5e47606df53cc40e334e",
      "6289ea0aecf3830e5e8d9925959bb6e804e324bb6db23c5701f7a538d12831f6",
      "fdbf2d02603235fdff99f0ceb57705ead95041d62de386387f2922e5d9f6c502",
      "ffa26139ca7f9d4849e118ff369fb3a387c8fefd8d15232b8353d4acf334324c"
   ],
   "isSolid":true,
   "shouldPromote":false,
   "shouldReattach":false
}

Message data:
{
   "message": {
      "networkId":"14379272398717627559",
      "parentMessageIds": [
         "27782707e4cbf84ca26b3db881bbf39b6429f9ee736a0cbe5a1c177d7a52b05d",
         "61cdf92c64a3304bbbabaf9fbfb0ea7ef9624e1eedea68efbe08595ccdf853e1",
         "a222d13e3ee51b56b0b0e38140a5f7f813b6d9e29b752d7e1e2424099455080d",
         "ab6bca20091b58dcbb0906438a7e47bfb11621c4a37b8d118b565f7f138a40d6"
      ],
      "payload": {
         "type":2,
         "index":"484f524e4554205370616d6d6572",
         "data":"42696e61727920697320746865206675747572652e0a436f756e743a2031333936393530390a54696d657374616d703a20323032312d30352d33315431353a33363a30392b30323a30300a54697073656c656374696f6e3a203337c2b573"
         },
      "nonce":"246736"
   },
   "messageId":"30d87fa9917602e5685638e37802bde11b260bd2379f6c850704d7babd365b44"
}
```

* `Client.getMessage().metadata()` provides information on how the given message fits to network structures, such as
`ledger_inclusion_state`, etc.
* `Client.getMessage().data()` provides all the data that relates to the given message and its payload(s).

### IndexationPayload

An [`IndexationPayload`](api_reference#indexationpayload) is a payload type that can be used to attach arbitrary `data`
and a key `index` to a message. You should provide the `index` at least to send the given payload. The data part
(as `bytes[]`) is optional.

<CodeBlock className="language-javascript">
  {data_message}
</CodeBlock>

**Output example**:

```json
{
   "message": {
      "networkId":"14379272398717627559",
      "parentMessageIds": [
         "1a383abbe5f6a6b0899d718975c3119643aa784a68d04075f4e986fd7a0c0e4b",
         "6098f889e31911833df7b7839e8b222d701ab496f7dfa1a719087edf4fa7ae52",
         "a98b47db4e8254eccc738c968bd35b08a5491e56d6c1a18af298c42bbd8c3a46",
         "da6796c0842c08de832c7948fffedc0d5adce372e50a108f26a128dba6096d31"
      ],
      "payload": {
         "type":2,
         "index":"494f54412e52532042494e44494e47202d204e4f44452e4a53",
         "data":"736f6d65207574662062617365642064617461"
      },
      "nonce":"13835058055282176519"
   },
   "messageId":"10f59c101cec669b0a0ba163bc777184c7f63455f5e771d42f910a1ba2ad20ff"
}
```

* You can check the given message using its `message_id` using the
[Tangle explorer](https://explorer.iota.org/devnet/message/8d4fa37be3c00691131c2c3e03e7b8b956c9118a2ce4be3a8597d51d82ed2de9)
* There are three prepared payloads(`transaction`, `milestone` and `indexation`). However, only the `indexation` payload
is used at the time.
* `data` contains arbitrary data encoded in bytes.
* Please note there is no IOTA address involved while sending data messages. Data messages are referenced using the
`message_id` or `index` key.
* IOTA addresses are part of the `UTXO` data structure that is sent using the [`SignedTransaction`](#SignedTransaction) payload.

### SignedTransaction

A `SignedTransaction` is a payload type that is used to transfer value-based messages as `UTXO` (Unspent Transaction
Output).

This core payload changes the ledger state as old `outputs` are spent (replaced) and new `outputs` are created.

```javascript
async function run(){
    const { ClientBuilder } = require('@iota/client');

    // client will connect to devnet by default
    const client = new ClientBuilder().build();

    const message_data = await client.getMessage().data("92f427d68c7008a81fde290b9cb99071373d9893d65718bfc22928273877e041");
    console.log(message_data);
}

run()
```

Example of a message with a `SignedTransaction` payload:

```json
{
	"message": {
		"networkId": "14379272398717627559",
		"parentMessageIds": [
			"a59a5d11da0944c88b58f9f9c095c11ee4b8b7fd9da47bd25412d39f815bb804",
			"c3d42c42eccd25bc3374a0552e3a4b21180facece14f31c36e5ac580e5496ccc",
			"dae4a36cef9a3fd03caff5ddbc5c90bc5523477f4e4937837202bfe4bd5b98aa",
			"fe188a4f57ecd6a135b05b31913d86617550d9397476ab5bb7445138f782ec34"
		],
		"payload": {
			"type": 0,
			"essence": {
				"type": 0,
				"inputs": [
					{
						"type": 0,
						"transactionId": "b2b9723c9119f4fb49084472e72821e842ba4779df02e1038f03dd8b25d96730",
						"transactionOutputIndex": 1
					}
				],
				"outputs": [
					{
						"type": 0,
						"address": {
							"type": 0,
							"address": "43e80947ebd17637569ba7f90fd2541f50038de731467c45aa5c92d4429c9446"
						},
						"amount": 1000
					},
					{
						"type": 0,
						"address": {
							"type": 0,
							"address": "b4d1e9abfbcf4d2d2f0e042f23301a7d23f6ac1bde0a1fed508de5afec884ba8"
						},
						"amount": 8995995
					}
				],
				"payload": null
			},
			"unlockBlocks": [
				{
					"type": 0,
					"signature": {
						"type": 0,
						"publicKey": "27177dd41cc479ed379b8ad2535d66fa58480c119a8a15a7a296f055401ab958",
						"signature": "8403dc1fb949365e960f14cdc19b6b3abb6b0a6bce83f1082a33e3857a30ddd2be1098074b6c261f442db8e59eb640002d24d9a577262fd8152c6fee2d076c0b"
					}
				}
			]
		},
		"nonce": "156106"
	},
	"messageId": "92f427d68c7008a81fde290b9cb99071373d9893d65718bfc22928273877e041"
}
```

Each `transaction` includes the following information:
* `inputs`: A list of valid `outputs` that should be used to fund the given message. Those `outputs` will be spent and
once the message is confirmed, those outputs are not valid anymore. Outputs are uniquely referenced via `transaction_id`
and inner `index`. At least one output has to be given with enough balance to source all `outputs` of the given message.
* `outputs`: A list of IOTA address(es) and related amount(s) that the input `outputs` should be split among. Based on
this information, new `UTXO` entities (outputs) will be being created.
* `unlock_blocks`: Includes a transaction signature(s) (currently based on `Ed25519` scheme) that prooves token
ownership based on a valid seed. Only the valid seed owner is able to correctly sign the given transaction and proove
ownership of the tokens under the given output(s). Each input `output` has to have a corresponding `unblockBlocks` entry
in case more `outputs` are used to fund the operation, either using the given signature or as a reference to the
existing signature
* `payload`: Each `SignedTransaction`(payload type 0) can include additional payload(s) such as an `IndexationPayload`
(payload type 1) for example. This means any value-based messages can also contain arbitrary data and its key index. It
is also an example how individual payloads can be encapsulated on different levels of concern

Sending value-based messages is also a very straightforward process via the [MessageSender](api_reference#messagesender) helper class.

You will minimally need to provide a valid seed, output addresses, and amount. The method will find valid output(s) that
can be used to fund the given amount(s) and the unspent amount is sent to the same address.

<CodeBlock className="language-javascript">
  {transaction}
</CodeBlock>

:::info
Though it is possible to send transactions with iota.rs, we strongly recommend that you use official
[`wallet.rs`](https://wiki.iota.org/wallet.rs/welcome) library together with the
[`stronghold.rs`](https://wiki.iota.org/stronghold.rs/welcome) enclave for value-based transfers. This combination
incorporates the best security practices while dealing with seeds, related addresses and `UTXO`.
:::

#### Dust Protection

:::note
There is a [dust protection](https://wiki.iota.org/chrysalis-docs/faq#what-is-dust-protection-and-how-does-it-work)
mechanism implemented in the network protocol to avoid malicious actors to spam network in an attempt to decrease node
performance while keeping track of unspent amount (`UTXO`).
:::

:::info
"... microtransaction below 1Mi of IOTA tokens [can be sent] to another address if there is already at least 1Mi on that address"
That's why we sent 1Mi in the given example to comply with the protection."
:::


## Listening to MQTT

IOTA node(s) provide a [Message Queuing Telemetry Transport](https://en.wikipedia.org/wiki/MQTT) (MQTT) layer, if
enabled, which is a lightweight publish-subscribe network protocol that provides information about events that are
being triggered by the IOTA network.

The `iota.rs` client library supports asynchronous event listeners that can be listened to, and continuously receive
MQTT events based on a `topic`, which can be:

* milestones/latest
* milestones/confirmed
* messages
* messages/referenced
* messages/indexation/{index}
* messages/{messageId}/metadata
* transactions/{transactionId}/included-message
* outputs/{outputId}
* addresses/{address}/outputs
* addresses/ed25519/{address}/outputs

You can reach the listener using an instance of a [Client.TopicSubscriber](api_reference#topicsubscriber) object that is
returned from the [`Client.subscriber()`](api_reference#subscriber-topicsubscriber) function.

It offers several chaining calls:

* `.topic(str)` / `.topics(str[])`: A topic or list of topics that should trigger a provided callback.
* `.subscribe(cb)`: Subscribes the listener to a callback function that is being triggered every time the given topic(s)
is noticed.
* `.unsubscribe(cb)`: Unsubscribes the listener from the given topics. Once unsubscribed, the given callback function is
executed in the form `(err, message) => {}`.

<CodeBlock className="language-javascript">
  {mqtt}
</CodeBlock>

:::note

The IOTA node needs to have the MQTT layer enabled. There is a set of test nodes available that have MQTT enabled.
You can find more information in the [devnet section](https://wiki.iota.org/chrysalis-docs/devnet/) of the Chrysalis
documentation.

:::
